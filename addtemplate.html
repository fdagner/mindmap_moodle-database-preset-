<style>
    #[[color_theme#id]] {
        background-color: #f8f9fa;
        border-color: #f8f9fa;
    }

    label[for="[[color_theme#id]]"] {
        display: block;
    }
</style>

<div class="main-content">
    <div class="zoom-controls">
        <div class="mindmap">
            <div class="mindmap_buttons">
                <button type="button" class="btn btn-light toggle-editor-btn" onclick="toggleEditor()"
                    title="Listenmodus umschalten"><i class="fa-solid fa-list"></i></button>
                <button type="button" class="btn btn-light" onclick="zoomSvg(1.2)" title="Hineinzoomen"><i
                        class="fa-solid fa-magnifying-glass-plus"></i></button>
                <button type="button" class="btn btn-light" onclick="zoomSvg(1/1.2)" title="Herauszoomen"><i
                        class="fa-solid fa-magnifying-glass-minus"></i></button>
                <button type="button" class="btn btn-light" onclick="resetZoom()" title="Zoom zurücksetzen"><i
                        class="fa-solid fa-arrows-to-circle"></i></button>
                [[color_theme]]
            </div>
        </div>
        <div class="editor-panel" style="display: none;">
            <div id="mindmapEditor" class="mindmap-tree"></div>
            <div class="export-area" style="display: none;">
                <strong>Mermaid Code:</strong>
                [[mermaid_text]]
            </div>
        </div>
        <div class="preview-panel">
            <div id="mermaidPreview" class="loading">
                <div id="welcomeMessage">
                    Klicke auf den Hauptknoten, um zu beginnen 😀...
                </div>
                <div id="svgZoomContainer"></div>
            </div>
        </div>
    </div>

    <div id="deleteModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Knoten löschen</h3>
            <p id="deleteModalMessage"></p>
            <div class="mindmap-modal-buttons" id="deleteModalButtons"></div>
        </div>
    </div>

    <div id="errorModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Fehler</h3>
            <p id="errorModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeErrorModal()">OK</button>
            </div>
        </div>
    </div>

    <div id="successModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Erfolg</h3>
            <p id="successModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeSuccessModal()">OK</button>
            </div>
        </div>
    </div>

    <div id="warningModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Warnung</h3>
            <p id="warningModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeWarningModal()">OK</button>
            </div>
        </div>
    </div>

    <script>

        let BRANCH_COLORS = BRANCH_COLORS_SCHEMES['Standard'].colors;
        const editor = document.getElementById('mindmapEditor');
        const previewContainer = document.getElementById('svgZoomContainer');
        const mermaidInput = document.getElementById('[[mermaid_text#id]]');
        const welcomeMessage = document.getElementById('welcomeMessage');

        // Function for setting the color scheme
        function setColorScheme() {
            const colorThemeSelect = document.getElementById('[[color_theme#id]]');
            if (!colorThemeSelect) return;

            let selectedScheme = colorThemeSelect.options[colorThemeSelect.selectedIndex].value;
            if (!selectedScheme) selectedScheme = 'Standard';

            if (BRANCH_COLORS_SCHEMES[selectedScheme]) {
                BRANCH_COLORS = [...BRANCH_COLORS_SCHEMES[selectedScheme].colors];
            } else {
                BRANCH_COLORS = [...BRANCH_COLORS_SCHEMES['Standard'].colors];
            }

            renderEditor();
            renderMindmap();
        }

        // Function to show/hide the editor
        const toggleEditor = () => {
            const editorPanel = document.querySelector('.editor-panel');
            const previewPanel = document.querySelector('.preview-panel');
            const toggleButton = document.querySelector('.toggle-editor-btn');
            const zoomButtons = document.querySelectorAll('.zoom-controls .btn.btn-light:not(.toggle-editor-btn)');

            if (editorPanel.style.display === 'none') {
                editorPanel.style.display = 'block';
                previewPanel.style.display = 'none';
                toggleButton.innerHTML = '<i class="fa-solid fa-lightbulb"></i>';
                zoomButtons.forEach(button => button.style.display = 'none');
                if (welcomeMessage) welcomeMessage.style.display = 'none'; // Hide message when switching to editor
            } else {
                editorPanel.style.display = 'none';
                previewPanel.style.display = 'block';
                toggleButton.innerHTML = '<i class="fa-solid fa-list"></i>';
                zoomButtons.forEach(button => button.style.display = 'inline-block');
                // Show message if no children and no interaction yet
                if (welcomeMessage && !hasInteractedWithRoot && !mindmapData.some(node => node.parent !== null)) {
                    welcomeMessage.style.display = 'block';
                }
            }
        };

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            if (!editor || !previewContainer || !mermaidInput || !welcomeMessage) {
                console.error('Required DOM elements are missing:', {
                    mindmapEditor: !!editor,
                    svgZoomContainer: !!previewContainer,
                    mermaidInput: !!mermaidInput,
                    welcomeMessage: !!welcomeMessage
                });
                showErrorModal('Interner Fehler: Erforderliche DOM-Elemente fehlen. Bitte überprüfen Sie die HTML-Struktur.');
                mindmapData = [];
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block';
                return;
            }
            initializeFromMermaidCode();
            setColorScheme();
            renderMindmap();
            const colorThemeSelect = document.getElementById('[[color_theme#id]]');
            if (colorThemeSelect) {
                colorThemeSelect.addEventListener('change', setColorScheme);
            }
        });


        // Zoom
        const zoomSvg = (factor) => {
            if (!previewContainer) return;
            currentZoom *= factor;
            previewContainer.style.transformOrigin = '0 0';
            previewContainer.style.transform = `scale(${currentZoom})`;
            document.getElementById('mermaidPreview').style.overflow = 'auto';
        };

        const resetZoom = () => {
            if (!previewContainer) return;
            currentZoom = 1;
            previewContainer.style.transform = 'none';
            document.getElementById('mermaidPreview').style.overflow = 'auto';
        };

        // Node validation
        const validateNodeText = (text, inputElement) => {
            if (!text.trim()) {
                showErrorModal('Die Eingabe darf nicht leer sein.');
                inputElement?.focus();
                return false;
            }
            if (text.length > MAX_TEXT_LENGTH) {
                showErrorModal(`Die Eingabe darf maximal ${MAX_TEXT_LENGTH} Zeichen lang sein.`);
                inputElement?.focus();
                return false;
            }
            if (/<[a-zA-Z0-9\s="/]*(>|\/>|on[a-zA-Z]+=["'])|[|~<>]/i.test(text)) {
                showErrorModal('Die Eingabe darf keinen HTML-Code, Skripte, "|", "~", "<" oder ">" enthalten.');
                inputElement?.focus();
                return false;
            }
            return true;
        };

        // Real-time input validation for SVG overlay
        const validateInputLength = (inputElement, nodeId) => {
            let text = inputElement.value;
            if (text.length > MAX_TEXT_LENGTH) {
                showErrorModal(`Die Eingabe darf maximal ${MAX_TEXT_LENGTH} Zeichen lang sein.`);
                inputElement.value = text.slice(0, MAX_TEXT_LENGTH);
                inputElement.focus();
            }
            if (/<[a-zA-Z0-9\s="/]*(>|\/>|on[a-zA-Z]+=["'])|[|~<>]/i.test(text)) {
                showErrorModal('Die Eingabe darf keinen HTML-Code, Skripte, "|", "~", "<" oder ">" enthalten.');
                inputElement.value = text.replace(/[<|~>]/g, '');
                inputElement.focus();
            }
        };


        // Initializes mind map data from Mermaid code
        function initializeFromMermaidCode() {
            if (!mermaidInput) {
                console.error('Element with ID "[[mermaid_text#id]]" not found in the DOM.');
                showErrorModal('Interner Fehler: Das Eingabefeld für den Mermaid-Code wurde nicht gefunden.');
                mindmapData = [];
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message for default case
                return;
            }

            const codeInput = mermaidInput.value;
            const lines = codeInput.split('|').map(line => line.trimEnd()).filter(line => line.trim().length > 0);

            mindmapData = [];
            let levelMap = {};
            let branchIndexCounter = 0;

            if (!codeInput.trim() || lines.length === 0 || (lines.length === 1 && lines[0].trim() === 'mindmap')) {
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                mermaidInput.value = 'mindmap|root(Hauptknoten)';
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message for empty mindmap
                return;
            }

            if (!lines[0] || lines[0].trim() !== 'mindmap') {
                lines.unshift('mindmap');
            }

            lines.forEach((line, index) => {
                if (line.trim() === 'mindmap') return;

                const match = line.match(/^(~*)[^~]*/);
                if (!match) return;
                const level = match[1] ? match[1].length : 0;
                const textWithIndent = match[0];

                if (level > MAX_LEVEL) return;

                let parentId = null;
                if (level > 0) {
                    for (let i = level - 1; i >= 0; i--) {
                        if (levelMap[i] !== undefined) {
                            parentId = levelMap[i];
                            break;
                        }
                    }
                }

                if (parentId !== null) {
                    const childrenCount = mindmapData.filter(node => node.parent === parentId).length;
                    if (childrenCount >= MAX_CHILDREN_PER_NODE) return;
                }

                let text = textWithIndent.replace(/^~*/, '').trim();
                if (text.startsWith('root(') && text.endsWith(')')) {
                    text = text.slice(5, -1);
                }

                if (!validateNodeText(text)) return;

                const siblings = mindmapData.filter(n => n.parent === parentId);
                const order = siblings.length;

                const branchIndex = level === 0 ? 0 :
                    level === 1 ? branchIndexCounter++ :
                        mindmapData.find(n => n.id === parentId)?.branchIndex || 0;

                const newNode = {
                    id: nodeCounter++,
                    text: text,
                    level: level,
                    parent: parentId,
                    order: order,
                    branchIndex: branchIndex
                };

                mindmapData.push(newNode);
                levelMap[level] = newNode.id;

                Object.keys(levelMap).forEach(key => {
                    if (parseInt(key) > level) {
                        delete levelMap[key];
                    }
                });
            });

            if (mindmapData.length === 0) {
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                mermaidInput.value = 'mindmap|root(Hauptknoten)';
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message for empty mindmap
            } else if (welcomeMessage && !mindmapData.some(node => node.parent !== null)) {
                welcomeMessage.style.display = 'block'; // Show message if no child nodes
            } else if (welcomeMessage) {
                welcomeMessage.style.display = 'none'; // Hide message if there are child nodes
            }

            renderEditor();
        }

        // Collapse/expand function for Level 1 nodes
        const toggleCollapse = (nodeId) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.level !== 1) return;
            node.isCollapsed = !node.isCollapsed;
            renderEditor();
        };

        // Checks whether a node is visible based on the isCollapsed state of its ancestors
        const isNodeVisible = (node) => {
            if (node.level === 0) return true;
            const parent = mindmapData.find(n => n.id === node.parent);
            if (!parent) return false;
            if (parent.level === 1 && parent.isCollapsed) return false;
            return isNodeVisible(parent);
        };

        // Node and editor rendering
        const getSortedNodes = () => {
            const nodes = [];
            const rootNodes = mindmapData.filter(node => node.level === 0).sort((a, b) => a.order - b.order);
            const addNodeAndChildren = node => {
                if (!isNodeVisible(node)) return;
                nodes.push(node);
                if (node.level === 1 && node.isCollapsed) return;
                mindmapData.filter(child => child.parent === node.id)
                    .sort((a, b) => (a.order || 0) - (b.order || 0))
                    .forEach(addNodeAndChildren);
            };
            rootNodes.forEach(addNodeAndChildren);
            return nodes;
        };

        const renderEditor = () => {
            if (!editor) return;
            editor.innerHTML = '';
            const sortedNodes = getSortedNodes();

            sortedNodes.forEach((node, index) => {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'node';
                nodeDiv.dataset.nodeId = node.id;
                nodeDiv.dataset.index = index;
                nodeDiv.dataset.level = node.level;
                nodeDiv.draggable = true;

                // Ensure that branchIndex is correct
                const parent = node.level > 0 ? mindmapData.find(n => n.id === node.parent) : null;
                node.branchIndex = node.level === 0 ? 0 :
                    node.level === 1 ? mindmapData.filter(n => n.parent === node.parent).sort((a, b) => (a.order || 0) - (b.order || 0)).indexOf(node) :
                        parent ? parent.branchIndex : 0;

                const collapseIcon = node.level === 1 ? `<span class="collapse-icon" onclick="toggleCollapse(${node.id})" title="${node.isCollapsed ? 'Ast ausklappen' : 'Ast einklappen'}">${node.isCollapsed ? '<i class="fa-solid fa-chevron-right"></i>' : '<i class="fa-solid fa-chevron-down"></i>'}</span>` : '';
                const addButton = node.level < MAX_LEVEL ? `
                    <button type="button" class="add-btn drop-zone-child" 
                            onclick="addChildNode(${node.id})" 
                            title="Unterknoten hinzufügen"
                            data-node-id="${node.id}"><i class="fa-solid fa-plus"></i></button>
                ` : '';
                const indent = node.level > 1 ? `<span class="indent">${'　'.repeat(node.level * 2)}</span>` : '';

                const colorThemeSelect = document.getElementById('[[color_theme#id]]');
                let selectedScheme = colorThemeSelect?.options[colorThemeSelect.selectedIndex]?.value || 'Standard';
                const inputBackgroundColor = node.level === 0 ? BRANCH_COLORS_SCHEMES[selectedScheme].level0 :
                    node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                        node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                            '#ffffff';
                const textColor = getContrastTextColor(inputBackgroundColor);

                nodeDiv.innerHTML = `
                    ${indent}
                    ${collapseIcon}
                    ${addButton}
                    <input type="text" class="node-input" value="${node.text}" 
                           style="background-color: ${inputBackgroundColor}; color: ${textColor};"
                           oninput="validateInputLength(this, ${node.id})"
                           onchange="updateNodeText(${node.id}, this.value, this)"
                           placeholder="Knotenbeschriftung eingeben" 
                           draggable="false" 
                           data-node-id="${node.id}">
                    <button type="button" class="delete-btn" 
                            onclick="showDeleteModal(${node.id})" 
                            title="${node.level > 0 ? 'Knoten löschen' : 'Hauptknoten löschen'}" 
                            data-node-id="${node.id}"><i class="fa-solid fa-trash"></i></button>
                `;

                nodeDiv.addEventListener('dragstart', handleDragStart);
                nodeDiv.addEventListener('touchstart', handleDragStart, { passive: false });
                nodeDiv.addEventListener('dragover', handleDragOver);
                nodeDiv.addEventListener('drop', handleDrop);
                nodeDiv.addEventListener('dragend', handleDragEnd);
                nodeDiv.addEventListener('dragenter', e => e.preventDefault());
                nodeDiv.addEventListener('dragleave', e => !e.target.closest('.node').contains(e.relatedTarget) && e.target.closest('.node').classList.remove('drag-over-child'));
                nodeDiv.addEventListener('touchmove', handleTouchMove, { passive: false });
                nodeDiv.addEventListener('touchend', handleTouchEnd, { passive: false });

                const inputElement = nodeDiv.querySelector('.node-input');
                const addBtn = nodeDiv.querySelector('.add-btn');
                const deleteBtn = nodeDiv.querySelector('.delete-btn');
                const collapseIconElement = nodeDiv.querySelector('.collapse-icon');

                [inputElement, addBtn, deleteBtn, collapseIconElement].forEach(el => {
                    if (el) {
                        el.addEventListener('dragstart', e => e.stopPropagation());
                        el.addEventListener('touchstart', e => e.stopPropagation(), { passive: false });
                    }
                });

                if (addBtn) {
                    addBtn.addEventListener('dragover', handleDropZoneDragOver);
                    addBtn.addEventListener('drop', e => handleDropZoneDrop(e, node.id, 'child'));
                }

                let isDragging = false;

                inputElement.addEventListener('mousedown', e => {
                    e.stopPropagation();
                    isDragging = false;
                    const input = e.target;
                    const rect = input.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const ctx = document.createElement('canvas').getContext('2d');
                    ctx.font = window.getComputedStyle(input).fontSize + ' ' + window.getComputedStyle(input).fontFamily;
                    const text = input.value;
                    let bestPosition = 0;
                    for (let i = 0; i <= text.length; i++) {
                        if (ctx.measureText(text.substring(0, i)).width + 10 >= clickX) {
                            bestPosition = i;
                            break;
                        }
                        bestPosition = i;
                    }
                    setTimeout(() => !isDragging && input.setSelectionRange(bestPosition, bestPosition), 0);
                });

                inputElement.addEventListener('click', e => {
                    e.stopPropagation();
                    if (isDragging) return e.preventDefault();
                    const input = e.target;
                    setTimeout(() => {
                        const rect = input.getBoundingClientRect();
                        if ((e.clientX - rect.left) > (rect.width - 20) * 0.9) {
                            input.setSelectionRange(input.value.length, input.value.length);
                        }
                    }, 10);
                });

                inputElement.addEventListener('keydown', e => (e.key === 'Enter' || e.keyCode === 13) && e.preventDefault() && e.target.blur());

                editor.appendChild(nodeDiv);
            });
        };

        // Node management
        const addChildNode = (parentId, isSvgMode = false) => {
            const parent = mindmapData.find(node => node.id === parentId);
            if (!parent) return;
            if (parent.level >= MAX_LEVEL) return showErrorModal(`Die maximale Tiefe von ${MAX_LEVEL} Ebenen wurde erreicht.`);
            if (mindmapData.filter(node => node.parent === parentId).length >= MAX_CHILDREN_PER_NODE) {
                return showErrorModal(`Der Elternknoten hat bereits die maximale Anzahl von ${MAX_CHILDREN_PER_NODE} Unterknoten erreicht.`);
            }
            const siblings = mindmapData.filter(node => node.parent === parentId);
            const newNode = {
                id: nodeCounter++,
                text: 'Neuer Knoten',
                level: parent.level + 1,
                parent: parentId,
                order: siblings.length > 0 ? Math.max(...siblings.map(s => s.order || 0)) + 1 : 0,
                branchIndex: parent.level === 0 ? siblings.length : parent.branchIndex,
                isCollapsed: parent.level === 1 ? false : undefined
            };
            mindmapData.push(newNode);
            if (parent.level === 1) parent.isCollapsed = false;
            renderEditor();
            renderMindmap();
            if (welcomeMessage && parent.level === 0) welcomeMessage.style.display = 'none';
            // Focus input in SVG mode only
            if (isSvgMode) {
                setTimeout(() => {
                    const svgContainer = document.querySelector('#svgZoomContainer svg');
                    if (svgContainer) {
                        const targetRect = svgContainer.querySelector(`rect[data-node-id="${newNode.id}"]`);
                        if (targetRect) {
                            const rect = targetRect.getBoundingClientRect();
                            const zoomFactor = currentZoom || 1;
                            const inputOverlay = document.createElement('div');
                            inputOverlay.className = 'input-overlay';
                            const overlayWidth = (rect.width / zoomFactor) * 1;
                            inputOverlay.style.left = `${rect.left + window.scrollX - (overlayWidth - rect.width / zoomFactor) / 2}px`;
                            inputOverlay.style.top = `${rect.top + window.scrollY}px`;
                            inputOverlay.style.width = `${overlayWidth}px`;
                            inputOverlay.style.height = `${rect.height / zoomFactor}px`;
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.value = newNode.text;
                            const colorThemeSelect = document.getElementById('[[color_theme#id]]');
                            let selectedScheme = colorThemeSelect?.options[colorThemeSelect.selectedIndex]?.value || 'Standard';
                            const inputBackgroundColor = newNode.level === 0 ? BRANCH_COLORS_SCHEMES[selectedScheme].level0 :
                                newNode.level === 1 ? BRANCH_COLORS[newNode.branchIndex % BRANCH_COLORS.length] :
                                    newNode.level === 2 ? BRANCH_COLORS[newNode.branchIndex % BRANCH_COLORS.length] :
                                        '#ffffff';
                            input.style.backgroundColor = inputBackgroundColor;
                            input.style.color = getContrastTextColor(inputBackgroundColor);
                            inputOverlay.appendChild(input);
                            document.body.appendChild(inputOverlay);
                            input.focus();
                            input.select();

                            let isSaving = false;

                            input.addEventListener('input', () => {
                                validateInputLength(input, newNode.id);
                            });

                            const saveInput = () => {
                                if (isSaving) return;
                                isSaving = true;
                                if (validateNodeText(input.value, input)) {
                                    updateNodeText(newNode.id, input.value, input);
                                    renderEditor();
                                }
                                if (inputOverlay.isConnected) {
                                    inputOverlay.remove();
                                }
                                document.removeEventListener('click', closeInputOverlay);
                                isSaving = false;
                            };

                            input.addEventListener('blur', saveInput);
                            input.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter' || e.keyCode === 13) {
                                    e.preventDefault();
                                    saveInput();
                                }
                            });

                            const closeInputOverlay = (e) => {
                                if (!inputOverlay.contains(e.target)) {
                                    saveInput();
                                }
                            };
                            document.addEventListener('click', closeInputOverlay);
                        }
                    }
                }, 100);
            } else {
                // In editor mode, focus the input field as before
                setTimeout(() => document.querySelector(`input[onchange*="${newNode.id}"]`)?.focus()?.select(), 100);
            }
        };


        const showDeleteModal = nodeId => {
            nodeToDelete = parseInt(nodeId);
            const node = mindmapData.find(n => n.id === nodeToDelete);
            if (!node) {
                nodeToDelete = null;
                return showErrorModal('Der ausgewählte Knoten wurde nicht gefunden.');
            }
            const hasChildren = mindmapData.some(n => n.parent === nodeToDelete);
            const buttons = node.level === 0 ? `
                <button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Abbrechen</button>
                <button type="button" class="btn btn-danger" onclick="confirmDelete(true, ${node.id})">Gesamte Mindmap löschen</button>
            ` : hasChildren ? `
                <button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Abbrechen</button>
                <button type="button" class="btn btn-danger" onclick="confirmDelete(false, ${node.id})">Nur diesen Knoten</button>
                <button type="button" class="btn btn-danger" onclick="confirmDelete(true, ${node.id})">Gesamten Ast</button>
            ` : `
                <button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Abbrechen</button>
                <button type="button" class="btn btn-danger" onclick="confirmDelete(false, ${node.id})">Knoten löschen</button>
            `;
            showModal('deleteModal', node.level === 0 ? 'Achtung, der Hauptknoten löscht die gesamte Mindmap.' :
                hasChildren ? 'Möchtest du nur diesen Knoten oder den gesamten Ast (inklusive Unterknoten) löschen?' :
                    'Möchtest du diesen Knoten löschen?', buttons);
        };

        const closeDeleteModal = () => closeModal('deleteModal');

        const confirmDelete = (deleteBranch, nodeId) => {
            const id = parseInt(nodeId);
            const node = mindmapData.find(n => n.id === id);
            if (!node) {
                closeDeleteModal();
                return showErrorModal('Der ausgewählte Knoten wurde nicht gefunden.');
            }
            if (node.level === 0) {
                mindmapData = [];
                nodeCounter = 0;
                const newRootNode = { id: nodeCounter++, text: 'Hauptknoten', level: 0, parent: null, order: 0, branchIndex: 0, isCollapsed: false };
                mindmapData.push(newRootNode);
                if (mermaidInput) mermaidInput.value = 'mindmap|root(Hauptknoten)';
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message after resetting mindmap
            } else if (deleteBranch) {
                deleteNodeAndChildren(id);
                normalizeOrders();
            } else {
                const children = mindmapData.filter(n => n.parent === id);
                const parentId = node.parent;
                const parentChildrenCount = mindmapData.filter(n => n.parent === parentId && n.id !== id).length;
                if (children.length + parentChildrenCount > MAX_CHILDREN_PER_NODE) {
                    showErrorModal(`Der Elternknoten würde die maximale Anzahl von ${MAX_CHILDREN_PER_NODE} Unterknoten überschreiten.`);
                    return closeDeleteModal();
                }
                children.forEach(child => {
                    if (child.level > MAX_LEVEL) {
                        showErrorModal(`Das Verschieben der Unterknoten würde die maximale Tiefe von ${MAX_LEVEL} Ebenen überschreiten.`);
                        return closeDeleteModal();
                    }
                    child.parent = parentId;
                    child.level = node.level;
                    child.branchIndex = node.branchIndex;
                });
                mindmapData = mindmapData.filter(n => n.id !== id);
                normalizeOrders();
            }
            renderEditor();
            renderMindmap();
            closeDeleteModal();
        };

        const deleteNodeAndChildren = id => {
            mindmapData.filter(node => node.parent === id).forEach(child => deleteNodeAndChildren(child.id));
            mindmapData = mindmapData.filter(node => node.id !== id);
            if (welcomeMessage && !mindmapData.some(node => node.parent !== null)) {
                welcomeMessage.style.display = 'block'; // Show message if no child nodes remain
            }
        };

        const updateNodeText = (nodeId, newText, inputElement) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || !validateNodeText(newText, inputElement)) {
                inputElement.value = node.text;
                return;
            }
            node.text = newText.trim();
            renderMindmap();
        };

        // Drag-and-drop and touch handling
        const getTargetElement = (x, y) => {
            let target = document.elementFromPoint(x, y);
            if (!target) {
                const nodes = document.querySelectorAll('.node');
                target = Array.from(nodes).find(node => {
                    const rect = node.getBoundingClientRect();
                    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
                });
            }
            return target;
        };

        const handleDragStart = e => {
            if (e.type === 'touchstart' && e.touches.length > 1) return;
            if (e.type === 'touchstart') e.preventDefault();
            const node = e.target.closest('.node');
            draggedNode = parseInt(node.dataset.nodeId);
            node.classList.add('dragging');
            document.querySelectorAll('.add-btn').forEach(btn => btn.style.boxShadow = '0 0 5px rgba(0, 0, 0, 0.3)');
            if (e.dataTransfer) e.dataTransfer.effectAllowed = 'move';
        };

        const handleDragOver = e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            document.querySelectorAll('.node').forEach(n => n.classList.remove('drag-over-child'));
            const targetNode = e.target.closest('.node');
            if (targetNode && parseInt(targetNode.dataset.nodeId) !== draggedNode) {
                targetNode.classList.add('drag-over-child');
            }
        };

        const handleDropZoneDragOver = e => {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'move';
            e.target.classList.add('drop-target');
        };

        const handleDropZoneDrop = (e, targetNodeId, dropType) => {
            e.preventDefault();
            e.stopPropagation();
            if (draggedNode !== targetNodeId) moveNodeAdvanced(draggedNode, targetNodeId, dropType);
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
        };

        const handleDrop = e => {
            e.preventDefault();
            const targetNodeId = parseInt(e.target.closest('.node').dataset.nodeId);
            if (draggedNode !== targetNodeId) moveNodeAdvanced(draggedNode, targetNodeId, 'child');
            document.querySelectorAll('.node').forEach(node => node.classList.remove('drag-over-child'));
        };

        const handleDragEnd = e => {
            e.target.closest('.node').classList.remove('dragging');
            draggedNode = null;
            document.querySelectorAll('.node').forEach(node => node.classList.remove('drag-over-child'));
            document.querySelectorAll('.add-btn').forEach(btn => {
                btn.style.boxShadow = 'none';
                btn.classList.remove('drop-target');
            });
        };

        const handleTouchMove = e => {
            if (!draggedNode || e.touches.length > 1) return;
            e.preventDefault();
            const touch = e.touches[0];
            document.querySelectorAll('.node').forEach(n => n.classList.remove('drag-over-child'));
            const targetNode = getTargetElement(touch.clientX, touch.clientY)?.closest('.node');
            if (targetNode && parseInt(targetNode.dataset.nodeId) !== draggedNode) {
                targetNode.classList.add('drag-over-child');
            }
        };

        const handleTouchEnd = e => {
            if (!draggedNode) return;
            e.preventDefault();
            const touch = e.changedTouches[0];
            const targetElement = getTargetElement(touch.clientX, touch.clientY);
            const targetNode = targetElement?.closest('.node');
            const dropZone = targetElement?.closest('.add-btn');

            if (dropZone && draggedNode !== parseInt(dropZone.dataset.nodeId)) {
                moveNodeAdvanced(draggedNode, parseInt(dropZone.dataset.nodeId), 'child');
            } else if (targetNode && draggedNode !== parseInt(targetNode.dataset.nodeId)) {
                moveNodeAdvanced(draggedNode, parseInt(targetNode.dataset.nodeId), 'child');
            }

            document.querySelectorAll('.node').forEach(node => node.classList.remove('dragging', 'drag-over-child'));
            document.querySelectorAll('.add-btn').forEach(btn => {
                btn.style.boxShadow = 'none';
                btn.classList.remove('drop-target');
            });
            draggedNode = null;
        };

        const moveNodeAdvanced = (nodeId, targetNodeId, dropType) => {
            const nodeToMove = mindmapData.find(n => n.id === nodeId);
            const targetNode = mindmapData.find(n => n.id === targetNodeId);
            if (!nodeToMove || !targetNode) return;
            if (isDescendant(nodeToMove.id, targetNode.id)) {
                return showErrorModal('Ein Knoten kann nicht zu seinem eigenen Unterknoten verschoben werden!');
            }
            if (dropType === 'child') {
                const childrenCount = mindmapData.filter(node => node.parent === targetNode.id && node.id !== nodeToMove.id).length;
                if (childrenCount >= MAX_CHILDREN_PER_NODE) {
                    return showErrorModal(`Der Zielknoten hat bereits die maximale Anzahl von ${MAX_CHILDREN_PER_NODE} Unterknoten erreicht.`);
                }
                const maxDepth = getMaxDepth(nodeToMove.id);
                const newLevel = targetNode.level + 1;
                if (newLevel + maxDepth > MAX_LEVEL) {
                    return showErrorModal(`Das Verschieben würde die maximale Tiefe von ${MAX_LEVEL} Ebenen überschreiten.`);
                }
                nodeToMove.parent = targetNode.id;
                nodeToMove.level = newLevel;
                const siblings = mindmapData.filter(node => node.parent === targetNode.id && node.id !== nodeToMove.id)
                    .sort((a, b) => (a.order || 0) - (b.order || 0));
                nodeToMove.order = siblings.length > 0 ? Math.max(...siblings.map(s => s.order || 0)) + 1 : 0;
                nodeToMove.branchIndex = targetNode.level === 0 ? siblings.length : targetNode.branchIndex;
                nodeToMove.isCollapsed = newLevel === 1 ? false : undefined;
                if (targetNode.level === 1) targetNode.isCollapsed = false;
                if (targetNode.level === 0 && welcomeMessage) welcomeMessage.style.display = 'none'; // Hide message when adding child to root
            }
            const parentId = nodeToMove.parent;
            const allSiblings = mindmapData.filter(node => node.parent === parentId)
                .sort((a, b) => (a.order || 0) - (b.order || 0));
            allSiblings.forEach((sibling, index) => {
                sibling.branchIndex = parentId === null ? index : mindmapData.find(n => n.id === parentId).branchIndex;
            });
            updateChildrenLevels(nodeToMove.id, nodeToMove.level);
            normalizeOrders();
            renderEditor();
            renderMindmap();
        };

        // Help functions for node structure
        const getMaxDepth = nodeId => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node) return 0;
            const children = mindmapData.filter(n => n.parent === nodeId);
            return children.length ? Math.max(...children.map(child => 1 + getMaxDepth(child.id))) : 0;
        };

        const isDescendant = (ancestorId, nodeId) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.parent === null) return false;
            return node.parent === ancestorId || isDescendant(ancestorId, node.parent);
        };

        const updateChildrenLevels = (nodeId, newLevel) => {
            mindmapData.filter(n => n.parent === nodeId).forEach(child => {
                child.level = newLevel + 1;
                child.branchIndex = mindmapData.find(n => n.id === nodeId).branchIndex;
                child.isCollapsed = child.level === 1 ? false : undefined;
                updateChildrenLevels(child.id, child.level);
            });
        };

        const normalizeOrders = () => {
            const groups = {};
            mindmapData.forEach(node => {
                const key = node.parent === null ? 'root' : node.parent;
                groups[key] = groups[key] || [];
                groups[key].push(node);
            });
            Object.values(groups).forEach(group => {
                group.sort((a, b) => (a.order || 0) - (b.order || 0) || a.id - b.id)
                    .forEach((node, index) => node.order = index + 1000);
            });
        };

        // Mermaid and SVG generation
        const generateMermaidCode = () => {
            if (!mindmapData.length) return 'mindmap|root(Hauptknoten)';
            const rootNode = mindmapData.find(node => node.level === 0);
            if (!rootNode) return 'mindmap|root(Hauptknoten)';
            const addNodeToMermaid = (node, level = 0) => {
                const indent = '~'.repeat(level);
                const text = node.text.replace(/[]/g, '');
                let nodeCode = node.level === 0 ? `${indent}root(${text})` : `${indent}${text}`;
                const children = mindmapData.filter(child => child.parent === node.id).sort((a, b) => (a.order || 0) - (b.order || 0));
                return nodeCode + children.map(child => '|' + addNodeToMermaid(child, level + 1)).join('');
            };
            return 'mindmap|' + addNodeToMermaid(rootNode);
        };

        const buildTreeFromData = () => {
            const nodesMap = new Map(mindmapData.map(node => [node.id, { ...node, children: [] }]));
            let root = null;
            nodesMap.forEach(node => {
                if (node.level === 0) root = node;
                if (node.parent !== null) {
                    const parent = nodesMap.get(node.parent);
                    if (parent) parent.children.push(node);
                }
            });
            const sortChildren = node => {
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach(sortChildren);
            };
            if (root) sortChildren(root);
            return root;
        };


        // Assign colors for branches
        const assignBranchColors = node => {
            const colorThemeSelect = document.getElementById('[[color_theme#id]]');
            let selectedScheme = colorThemeSelect?.options[colorThemeSelect.selectedIndex]?.value || 'Standard';
            node.color = node.level === 0 ? BRANCH_COLORS_SCHEMES[selectedScheme].level0 :
                node.level < BRANCH_COLORS.length ? BRANCH_COLORS[node.level] : '#999';
            node.textColor = getContrastTextColor(node.color);
            node.borderColor = node.level === 0 ? BRANCH_COLORS_SCHEMES[selectedScheme].level0 : node.color;
            node.children.forEach((child, index) => {
                assignBranchColors(child);
            });
        };


        const countNodes = node => 1 + node.children.reduce((sum, child) => sum + countNodes(child), 0);

        // Calculate sub-tree size
        const calculateSubtreeSize = (node) => {
            const fontSize = Math.max(12, 18 - node.level);
            const maxWidth = 200;
            const words = node.text.split(' ').flatMap(word => {
                if (measureTextWidth(word, fontSize) > maxWidth) {
                    return splitLongWord(word, maxWidth, fontSize);
                }
                return word;
            });
            let line = '';
            const lines = [];

            words.forEach(word => {
                const testLine = line + word + ' ';
                if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = testLine;
                }
            });
            if (line.length > 0) lines.push(line.trim());

            const lineHeight = fontSize * 1.2;
            node.height = lines.length * lineHeight + 20;
            node.width = Math.max(100, maxWidth + 20);

            if (!node.children.length) {
                node.subtreeWidth = node.width;
                node.subtreeHeight = node.height;
                return;
            }
            node.children.forEach(calculateSubtreeSize);
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            node.subtreeHeight = node.children.reduce((sum, child) => sum + child.subtreeHeight, 0) + Math.max(0, node.children.length - 1) * spacing;
            node.subtreeWidth = node.width + 100 + Math.max(...node.children.map(c => c.subtreeWidth));
        };

        // Position nodes
        const positionNode = (node, x, y, direction) => {
            if (typeof node.x === 'undefined') {
                node.x = direction === 'left' ? x - node.width : x;
            }
            node.y = y + (node.subtreeHeight - node.height) / 2;
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            let currentY = y;
            node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
            node.children.forEach(child => {
                const childDirection = child.direction || direction;
                const offset = 100;
                const childX = childDirection === 'right' ? node.x + node.width + offset : node.x - offset;
                positionNode(child, childX, currentY, childDirection);
                currentY += child.subtreeHeight + spacing;
            });
        };

        // Calculate layout
        const calculateLayout = (node, level = 0) => {
            if (level === 0) {
                calculateSubtreeSize(node);
                let rightChildren = [];
                let leftChildren = [];
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach((child, index) => {
                    child.direction = index % 2 === 0 ? 'right' : 'left';
                    if (child.direction === 'right') rightChildren.push(child);
                    else leftChildren.push(child);
                });

                const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));

                let rightTotalHeight = rightChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, rightChildren.length - 1) * spacing;
                let leftTotalHeight = leftChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, leftChildren.length - 1) * spacing;
                let maxTotalHeight = Math.max(leftTotalHeight, rightTotalHeight, node.height);

                const maxRightWidth = rightChildren.reduce((max, c) => Math.max(max, c.subtreeWidth), 0);
                const maxLeftWidth = leftChildren.reduce((max, c) => Math.max(max, c.subtreeWidth), 0);
                const maxBranchWidth = Math.max(maxRightWidth, maxLeftWidth);
                const totalWidth = node.width + 2 * maxBranchWidth + 200;

                node.x = maxBranchWidth + 100;
                node.y = maxTotalHeight / 2 - node.height / 2;

                let rightY = node.y + node.height / 2 - rightTotalHeight / 2;
                rightChildren.forEach(child => {
                    positionNode(child, node.x + node.width + 100, rightY, 'right');
                    rightY += child.subtreeHeight + spacing;
                });

                let leftY = node.y + node.height / 2 - leftTotalHeight / 2;
                leftChildren.forEach(child => {
                    const rightEdgeX = node.x - 100;
                    positionNode(child, rightEdgeX, leftY, 'left');
                    leftY += child.subtreeHeight + spacing;
                });
            }
        };

        // Calculate connection points
        const getConnectionPoint = (fromNode, toNode) => {
            const fromCenterX = fromNode.x + fromNode.width / 2;
            const fromCenterY = fromNode.y + fromNode.height / 2;
            const toCenterX = toNode.x + toNode.width / 2;
            const toCenterY = toNode.y + toNode.height / 2;
            const dx = toCenterX - fromCenterX;
            const dy = toCenterY - fromCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            return {
                fromX: fromCenterX + normalizedDx * (fromNode.width / 2),
                fromY: fromCenterY + normalizedDy * (fromNode.height / 2),
                toX: toCenterX - normalizedDx * (toNode.width / 2),
                toY: toCenterY - normalizedDy * (toNode.height / 2)
            };
        };

        // Generate SVG
        const generateSVG = root => {
            if (!root) return '';
            const padding = 100;
            assignBranchColors(root);
            calculateLayout(root);
            const { minX, minY, maxX, maxY } = getBounds(root);
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;
            let svg = `<svg width="${width}" height="${height}" viewBox="${minX - padding} ${minY - padding} ${width} ${height}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">`;
            const drawConnections = node => {
                node.children.forEach(child => {
                    const { fromX, fromY, toX, toY } = getConnectionPoint(node, child);
                    svg += `<line x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}" stroke="${BRANCH_COLORS[child.branchIndex % BRANCH_COLORS.length] || '#667eea'}" stroke-width="2" stroke-linecap="round"/>`;
                    drawConnections(child);
                });
            };
            const drawNodes = node => {
                const colorThemeSelect = document.getElementById('[[color_theme#id]]');
                let selectedScheme = colorThemeSelect?.options[colorThemeSelect.selectedIndex]?.value || 'Standard';
                const { fillColor, fillOpacity, strokeColor, strokeWidth, strokeDasharray } = node.level === 0
                    ? { fillColor: BRANCH_COLORS_SCHEMES[selectedScheme].level0, strokeColor: BRANCH_COLORS_SCHEMES[selectedScheme].level0, strokeWidth: 2, strokeDasharray: 'none' }
                    : node.level === 1
                        ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: 'none' }
                        : node.level === 2
                            ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], fillOpacity: '0.6', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' }
                            : { fillColor: '#ffffff', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' };
                const textColor = getContrastTextColor(fillColor);
                svg += `<rect data-node-id="${node.id}" class="node-rect" x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="8" fill="${fillColor}" fill-opacity="${fillOpacity}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${strokeDasharray}"/>`;
                const words = node.text.split(' ').flatMap(word => {
                    const fontSize = Math.max(12, 18 - node.level);
                    if (measureTextWidth(word, fontSize) > 200) {
                        return splitLongWord(word, 200, fontSize);
                    }
                    return word;
                });
                let line = '';
                const lines = [];
                const maxWidth = 200;
                const fontSize = Math.max(12, 18 - node.level);
                words.forEach(word => {
                    const testLine = line + word + ' ';
                    if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                        lines.push(line.trim());
                        line = word + ' ';
                    } else {
                        line = testLine;
                    }
                });
                if (line.length > 0) lines.push(line.trim());
                const lineHeight = fontSize * 1.2;
                const totalTextHeight = lines.length * lineHeight;
                const startY = node.y + (node.height - totalTextHeight) / 2 + lineHeight * 0.7;
                lines.forEach((textLine, index) => {
                    svg += `<text data-node-id="${node.id}" class="node-text" x="${node.x + node.width / 2}" y="${startY + index * lineHeight}" font-size="${fontSize}" font-family="Inter, system-ui, sans-serif" fill="${textColor}" text-anchor="middle" font-weight="${node.level === 0 ? '600' : '400'}">${textLine}</text>`;
                });
                node.children.forEach(drawNodes);
            };
            drawConnections(root);
            drawNodes(root);
            svg += '</svg>';
            return svg;
        };

        // Grenzen berechnen
        const getBounds = root => {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const updateBounds = node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
                node.children.forEach(updateBounds);
            };
            updateBounds(root);
            return { minX, minY, maxX, maxY };
        };

        // Render mind maps
        const renderMindmap = () => {
            if (!mermaidInput) return;
            mermaidInput.value = generateMermaidCode();
            if (!previewContainer) return;
            previewContainer.innerHTML = '<div class="loading">Rendere Mindmap...</div>';
            try {
                const root = buildTreeFromData();
                const svg = generateSVG(root);
                previewContainer.innerHTML = `<div id="mermaid-container-${Date.now()}" class="mermaid-container">${svg}</div>`;
                const existingOverlay = document.querySelector('.node-action-overlay, .input-overlay');
                if (existingOverlay) existingOverlay.remove();
                const svgContainer = previewContainer.querySelector('svg');
                if (svgContainer) {
                    svgContainer.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const existingOverlay = document.querySelector('.node-action-overlay, .input-overlay');
                        if (existingOverlay) existingOverlay.remove();
                        const target = e.target.closest('[data-node-id]');
                        if (target) {
                            const nodeId = parseInt(target.getAttribute('data-node-id'));
                            const node = mindmapData.find(n => n.id === nodeId);
                            if (!node) {
                                showErrorModal('Knoten nicht gefunden.');
                                return;
                            }
                            if (node.level === 0 && !hasInteractedWithRoot) {
                                hasInteractedWithRoot = true;
                                if (welcomeMessage) welcomeMessage.style.display = 'none';
                            }
                            if (node.level === 0 && e.target.classList.contains('delete-btn')) {
                                showErrorModal('Der Hauptknoten kann nicht gelöscht werden.');
                                return;
                            }
                            const rects = svgContainer.querySelectorAll(`rect[data-node-id="${nodeId}"]`);
                            const texts = svgContainer.querySelectorAll(`text[data-node-id="${nodeId}"]`);
                            [rects, texts].forEach(elements => {
                                elements.forEach(el => {
                                    el.classList.add('node-highlighted');
                                    setTimeout(() => el.classList.remove('node-highlighted'), 500);
                                });
                            });

                            const rect = target.getBoundingClientRect();
                            const zoomFactor = currentZoom || 1;
                            const overlay = document.createElement('div');
                            overlay.className = 'node-action-overlay';
                            overlay.style.left = `${rect.left + window.scrollX}px`;
                            overlay.style.top = `${rect.bottom + window.scrollY + 5}px`;
                            overlay.innerHTML = `
                        <button class="edit-btn" title="Knoten bearbeiten"><i class="fa-solid fa-edit"></i></button>
                        <button class="plus-btn" title="Neuer Unterknoten"><i class="fa-solid fa-plus"></i></button>
                        <button class="delete-btn" title="Knoten löschen"><i class="fa-solid fa-trash"></i></button>
                    `;
                            document.body.appendChild(overlay);
                            overlay.querySelector('.edit-btn').addEventListener('click', (e) => {
                                e.stopPropagation();
                                overlay.remove();
                                const inputOverlay = document.createElement('div');
                                inputOverlay.className = 'input-overlay';
                                const overlayWidth = (rect.width / zoomFactor) * 1;
                                inputOverlay.style.left = `${rect.left + window.scrollX - (overlayWidth - rect.width / zoomFactor) / 2}px`;
                                inputOverlay.style.top = `${rect.top + window.scrollY}px`;
                                inputOverlay.style.width = `${overlayWidth}px`;
                                inputOverlay.style.height = `${rect.height / zoomFactor}px`;
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.value = node.text;
                                const colorThemeSelect = document.getElementById('[[color_theme#id]]');
                                let selectedScheme = colorThemeSelect?.options[colorThemeSelect.selectedIndex]?.value || 'Standard';
                                const inputBackgroundColor = node.level === 0 ? BRANCH_COLORS_SCHEMES[selectedScheme].level0 :
                                    node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                                        node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                                            '#ffffff';
                                input.style.backgroundColor = inputBackgroundColor;
                                input.style.color = getContrastTextColor(inputBackgroundColor);
                                inputOverlay.appendChild(input);
                                document.body.appendChild(inputOverlay);
                                input.focus();
                                input.select();

                                let isSaving = false;

                                input.addEventListener('input', () => {
                                    validateInputLength(input, nodeId);
                                });

                                const saveInput = () => {
                                    if (isSaving) return;
                                    isSaving = true;
                                    if (validateNodeText(input.value, input)) {
                                        updateNodeText(nodeId, input.value, input);
                                        renderEditor();
                                    }
                                    if (inputOverlay.isConnected) {
                                        inputOverlay.remove();
                                    }
                                    document.removeEventListener('click', closeInputOverlay);
                                    isSaving = false;
                                };

                                input.addEventListener('blur', saveInput);
                                input.addEventListener('keydown', (e) => {
                                    if (e.key === 'Enter' || e.keyCode === 13) {
                                        e.preventDefault();
                                        saveInput();
                                    }
                                });

                                const closeInputOverlay = (e) => {
                                    if (!inputOverlay.contains(e.target)) {
                                        saveInput();
                                    }
                                };
                                document.addEventListener('click', closeInputOverlay);
                            });
                            overlay.querySelector('.plus-btn').addEventListener('click', (e) => {
                                e.stopPropagation();
                                if (!node || node.id !== nodeId) {
                                    showErrorModal('Fehler: Ungültiger Knoten ausgewählt.');
                                    overlay.remove();
                                    return;
                                }
                                if (node.level >= MAX_LEVEL) {
                                    showErrorModal(`Die maximale Tiefe von ${MAX_LEVEL} Ebenen wurde erreicht.`);
                                    overlay.remove();
                                    return;
                                }
                                const children = mindmapData.filter(n => n.parent === nodeId);
                                if (children.length >= MAX_CHILDREN_PER_NODE) {
                                    showErrorModal(`Der Elternknoten hat bereits die maximale Anzahl von ${MAX_CHILDREN_PER_NODE} Unterknoten erreicht.`);
                                    overlay.remove();
                                    return;
                                }
                                addChildNode(nodeId, true);
                                overlay.remove();
                            });
                            overlay.querySelector('.delete-btn').addEventListener('click', (e) => {
                                e.stopPropagation();
                                overlay.remove();
                                showDeleteModal(nodeId);
                            });
                            const closeOverlay = (e) => {
                                if (!overlay.contains(e.target) && !target.contains(e.target)) {
                                    overlay.remove();
                                    document.removeEventListener('click', closeOverlay);
                                }
                            };
                            document.addEventListener('click', closeOverlay);
                        }
                    });
                }
                // Corrected welcome message logic with proper syntax
                if (welcomeMessage && typeof hasInteractedWithRoot !== 'undefined' && !hasInteractedWithRoot && !mindmapData.some(node => node.parent !== null)) {
                    welcomeMessage.style.display = 'block';
                } else if (welcomeMessage) {
                    welcomeMessage.style.display = 'none';
                }
            } catch (error) {
                const mermaidCode = mermaidInput.value.split('|').map(line => {
                    const match = line.match(/^(~*)[^~]*/);
                    return match ? ' '.repeat(match[1]?.length || 0) + match[0].replace(/^~*/, '') : line;
                }).join('\n');
                previewContainer.innerHTML = `
            <div style="background: #f1f3f4; padding: 20px; border-radius: 12px; border-left: 4px solid #dc2626;">
                <h4 style="margin: 0 0 10px 0; color: #dc2626;">⚠️ Vorschau nicht verfügbar</h4>
                <p style="color: #6b7280; margin: 0 0 15px 0; font-size: 14px;">Rendering-Fehler: ${error.message}</p>
                <h5 style="margin: 15px 0 10px 0; color: #1f2937;">📋 Generierter Code:</h5>
                <pre style="background: white; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4; overflow-x: auto; margin: 0; border: 1px solid #e5e7eb;">${mermaidCode}</pre>
            </div>
        `;
                if (welcomeMessage) welcomeMessage.style.display = 'none';
            }
        };
    </script>
</div>