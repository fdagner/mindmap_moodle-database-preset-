<div class="conceptmap">
  <div class="inner">
    <table class="table"><tr><td><h4>Thema</h4></td><td style="width: 100%">[[thema]]</td></tr></table>
    <div id="toolbar" class="container-fluid bg-dark text-white p-3 d-flex flex-wrap align-items-center gap-2">
      <button type="button" id="addNode" class="btn btn-primary btn-sm"><i class="fa-solid fa-plus"></i> Element</button>
      <button type="button" id="deleteMode" class="btn btn-danger btn-sm"><i class="fa-solid fa-trash"></i> Löschen</button>
      <div class="btn-group btn-group-sm flex-wrap align-items-center gap-2" role="group">
        <button type="button" class="btn btn-outline-light rounded-circle color-button" style="width: 30px; height: 30px; padding: 0; background-color: #fff;" data-color="#e6f3fa" title="Weiß"></button>
        <button type="button" class="btn btn-outline-light rounded-circle color-button" style="width: 30px; height: 30px; padding: 0; background-color: #e6f3fa;" data-color="#e6f3fa" title="Blau"></button>
        <button type="button" class="btn btn-outline-light rounded-circle color-button" style="width: 30px; height: 30px; padding: 0; background-color: #f0e6fa;" data-color="#f0e6fa" title="Lila"></button>
        <button type="button" class="btn btn-outline-light rounded-circle color-button" style="width: 30px; height: 30px; padding: 0; background-color: #e6fae6;" data-color="#e6fae6" title="Grün"></button>
        <button type="button" class="btn btn-outline-light rounded-circle color-button" style="width: 30px; height: 30px; padding: 0; background-color: #faf0e6;" data-color="#faf0e6" title="Orange"></button>
        <button type="button" class="btn btn-outline-light rounded-circle color-button" style="width: 30px; height: 30px; padding: 0; background-color: #f5f5e6;" data-color="#f5f5e6" title="Gelb"></button>
      </div>
      <button type="button" id="clearAll" class="btn btn-warning btn-sm"><i class="fa-solid fa-arrows-rotate"></i> Neu beginnen</button>
      <i class="fas fa-question-circle text-primary fa-2x ms-2" data-bs-toggle="modal" data-bs-target="#conceptMapModal" style="cursor:pointer;"></i>
      <div style="display: none;">[[code]]</div>
    </div>
    <div id="canvas" style="touch-action: auto;">
      <svg id="svg"></svg>
    </div>
  </div>
</div>

<div class="modal fade" id="conceptMapModal" tabindex="-1" aria-labelledby="conceptMapModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg">
    <div class="modal-content">
      <div class="modal-header bg-primary text-white">
        <h5 class="modal-title" id="conceptMapModalLabel">So erstellst du eine Concept Map</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Schließen"></button>
      </div>
      <div class="modal-body">
        <h6>1. Thema festlegen</h6>
        <p>Wähle ein Thema, das du darstellen möchtest, z. B. <em>Jahreszeiten</em> oder <em>Wasser</em>.</p>
        <h6>2. Begriffe sammeln</h6>
        <p>Schreibe alle wichtigen Begriffe auf, die dir zu deinem Thema einfallen.</p>
        <h6>3. Begriffe ordnen</h6>
        <p>Platziere den zentralen Begriff in die Mitte und ordne verwandte Begriffe drumherum.</p>
        <h6>4. Beziehungen beschriften</h6>
        <p>Verbinde Begriffe mit Pfeilen und beschrifte die Pfeile mit Verben:</p>
        <ul>
          <li>Sonne <em>erwärmt</em> Erde</li>
          <li>Wärme <em>führt zu</em> Sommer</li>
          <li>Kälte <em>führt zu</em> Winter</li>
          <li>Regen <em>entsteht durch</em> Wolken</li>
          <li>Pflanzenwachstum <em>nimmt zu bei</em> Wärme</li>
        </ul>
        <h6>5. Farben für Kategorien</h6>
        <p>Verwende Farben, um Gruppen zu kennzeichnen:</p>
        <ul>
          <li><span style="color:goldenrod">Gelb</span> = Energie & Sonne</li>
          <li><span style="color:royalblue">Blau</span> = Wetter & Klima</li>
          <li><span style="color:green">Grün</span> = Natur & Wachstum</li>
          <li><span style="color:purple">Violett</span> = Zeitabschnitte</li>
        </ul>
        <h6>6. Überprüfen</h6>
        <p>Lies deine Concept Map laut vor – ergibt jeder Pfeil eine sinnvolle Aussage?</p>
        <hr />
        <p class="text-muted text-center"> Tipp: Farben zeigen Kategorien, Pfeile zeigen Beziehungen. Zusammen ergibt das Wissen mit Struktur! </p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Schließen</button>
      </div>
    </div>
  </div>
</div>

<script>
  const canvas = document.querySelector('.conceptmap #canvas');
  const svg = document.querySelector('.conceptmap #svg');
  const jsonInput = document.querySelector('.conceptmap #[[code#id]]');
let isSelecting = false;  // Flag, um Drags während Select zu blocken
let selectTimeout = null; // Timeout für Click-Intent-Erkennung
let dragThreshold = 10;   // Neu: Erhöhte Schwelle (von 5 auf 10px), ignoriert Zucken
  let nodes = [];
  let connections = [];
  let connectStart = null;
  let draggedNode = null;
  let draggedControl = null;
  let potentialDraggedControl = null;
  let dragStartPos = { x: 0, y: 0 };
  let hasMoved = false;
  let selectedNode = null;
  let selectedConnection = null;
  let nodeIdCounter = 1;
  let connectionIdCounter = 1;
  let lastTapTime = 0;

  // SVG Pfeilspitze definieren
  svg.innerHTML = `
    <defs>
      <marker id="arrowhead" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
        <polygon points="0 0, 8 4, 0 8" fill="#2c3e50" />
      </marker>
    </defs>
  `;

  // Initialisierung: JSON aus Input laden
  window.addEventListener('load', () => {
    if (jsonInput.value.trim()) {
      loadFromJSON(jsonInput.value);
    }
  });

  // Funktion zum Berechnen des Randpunkts
  function getBorderPoint(lineStartX, lineStartY, lineEndX, lineEndY, rect, canvasRect) {
    const dx = lineEndX - lineStartX;
    const dy = lineEndY - lineStartY;
    const left = rect.left - canvasRect.left;
    const top = rect.top - canvasRect.top;
    const right = left + rect.width;
    const bottom = top + rect.height;
    const intersections = [];

    if (dx !== 0) {
      const t = (left - lineStartX) / dx;
      if (t > 0 && t <= 1) {
        const y = lineStartY + t * dy;
        if (y >= top && y <= bottom) intersections.push({x: left, y, t});
      }
    }

    if (dx !== 0) {
      const t = (right - lineStartX) / dx;
      if (t > 0 && t <= 1) {
        const y = lineStartY + t * dy;
        if (y >= top && y <= bottom) intersections.push({x: right, y, t});
      }
    }

    if (dy !== 0) {
      const t = (top - lineStartY) / dy;
      if (t > 0 && t <= 1) {
        const x = lineStartX + t * dx;
        if (x >= left && x <= right) intersections.push({x, y: top, t});
      }
    }

    if (dy !== 0) {
      const t = (bottom - lineStartY) / dy;
      if (t > 0 && t <= 1) {
        const x = lineStartX + t * dx;
        if (x >= left && x <= right) intersections.push({x, y: bottom, t});
      }
    }

    if (intersections.length > 0) {
      intersections.sort((a, b) => a.t - b.t);
      return intersections[0];
    }
    return {x: lineEndX, y: lineEndY};
  }

  let mode = 'default';

  // Hilfsfunktion für Double-Tap-Erkennung
  function isDoubleTap() {
    const currentTime = Date.now();
    const tapLength = currentTime - lastTapTime;
    lastTapTime = currentTime;
    return tapLength < 500 && tapLength > 0;
  }

  // Touch drag handler factory
  function createTouchDragHandler(isNode = true) {
    return function touchMoveHandler(e) {
      const touch = e.touches[0];
      if (isNode && draggedNode) {
        const deltaX = Math.abs(touch.clientX - dragStartPos.x);
        const deltaY = Math.abs(touch.clientY - dragStartPos.y);
        
        if (deltaX > 5 || deltaY > 5) {
          e.preventDefault();
          hasMoved = true;
          const canvasRect = canvas.getBoundingClientRect();
          const nodeRect = draggedNode.element.getBoundingClientRect();
          let newX = touch.clientX - canvasRect.left - (nodeRect.width / 2);
          let newY = touch.clientY - canvasRect.top - (nodeRect.height / 2);

          newX = Math.max(0, Math.min(newX, canvasRect.width - nodeRect.width));
          newY = Math.max(0, Math.min(newY, canvasRect.height - nodeRect.height));

          draggedNode.x = newX;
          draggedNode.y = newY;
          draggedNode.element.style.left = newX + 'px';
          draggedNode.element.style.top = newY + 'px';
          const rect = draggedNode.element.getBoundingClientRect();
          draggedNode.connectBtn.style.left = `${rect.right - canvasRect.left}px`;
          draggedNode.connectBtn.style.top = `${rect.top - canvasRect.top - 18}px`;
          renderConnections();
        }
      } else if (draggedControl) {
        const deltaX = Math.abs(touch.clientX - dragStartPos.x);
        const deltaY = Math.abs(touch.clientY - dragStartPos.y);
        
        if (deltaX > 5 || deltaY > 5) {
          e.preventDefault();
          draggedControl.isDragging = true;
          const canvasRect = canvas.getBoundingClientRect();
          let newX = touch.clientX - canvasRect.left;
          let newY = touch.clientY - canvasRect.top;

          newX = Math.max(0, Math.min(newX, canvasRect.width));
          newY = Math.max(0, Math.min(newY, canvasRect.height));

          const fromNode = nodes.find(n => n.id === draggedControl.from);
          const toNode = nodes.find(n => n.id === draggedControl.to);
          if (fromNode && toNode) {
            const fromRect = fromNode.element.getBoundingClientRect();
            const toRect = toNode.element.getBoundingClientRect();
            const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
            const y2 = toRect.top + toRect.height / 2 - canvasRect.top;
            
            let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect) || {x: x1, y: y1};
            let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect) || {x: x2, y: y2};

            const t = 0.5;
            draggedControl.controlX = (newX - (1 - t) ** 2 * startPoint.x - t ** 2 * endPoint.x) / (2 * (1 - t) * t);
            draggedControl.controlY = (newY - (1 - t) ** 2 * startPoint.y - t ** 2 * endPoint.y) / (2 * (1 - t) * t);
          }

          dragStartPos.x = touch.clientX;
          dragStartPos.y = touch.clientY;
          renderConnections();
          saveToJSON();
        }
      } else if (potentialDraggedControl) {
        const deltaX = Math.abs(touch.clientX - dragStartPos.x);
        const deltaY = Math.abs(touch.clientY - dragStartPos.y);
        
        if (deltaX > 5 || deltaY > 5) {
          e.preventDefault();
          hasMoved = true;
          draggedControl = potentialDraggedControl;
          potentialDraggedControl = null;
          draggedControl.isDragging = true;
          const canvasRect = canvas.getBoundingClientRect();
          let newX = touch.clientX - canvasRect.left;
          let newY = touch.clientY - canvasRect.top;

          newX = Math.max(0, Math.min(newX, canvasRect.width));
          newY = Math.max(0, Math.min(newY, canvasRect.height));

          const fromNode = nodes.find(n => n.id === draggedControl.from);
          const toNode = nodes.find(n => n.id === draggedControl.to);
          if (fromNode && toNode) {
            const fromRect = fromNode.element.getBoundingClientRect();
            const toRect = toNode.element.getBoundingClientRect();
            const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
            const y2 = toRect.top + toRect.height / 2 - canvasRect.top;
            
            let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect) || {x: x1, y: y1};
            let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect) || {x: x2, y: y2};

            const t = 0.5;
            draggedControl.controlX = (newX - (1 - t) ** 2 * startPoint.x - t ** 2 * endPoint.x) / (2 * (1 - t) * t);
            draggedControl.controlY = (newY - (1 - t) ** 2 * startPoint.y - t ** 2 * endPoint.y) / (2 * (1 - t) * t);
          }

          dragStartPos.x = touch.clientX;
          dragStartPos.y = touch.clientY;
          renderConnections();
        }
      }
    };
  }

  function createTouchEndHandler() {
  return function touchEndHandler(e) {
    if (draggedNode) {
      if (hasMoved) {
        saveToJSON();
      }
      draggedNode = null;
      hasMoved = false;
    }
    if (draggedControl) {
      if (draggedControl.isDragging) {
        saveToJSON();
      }
      draggedControl.isDragging = false;
      draggedControl = null;
    }

    potentialDraggedControl = null;
  };
}

// FIX: Zentraler Touch-Handler, der bei Berührung AUSSERHALB der Elemente den Zustand zurücksetzt.
// Korrektur: Berücksichtigt jetzt auch die Steuerelemente und den Verbindungs-Button.
document.addEventListener('touchstart', (e) => {
  const target = e.target;
  const isCanvasElement = target === canvas || target === svg;
  const isNodeElement = target.closest('.node');
  const isLabelElement = target.closest('.connection-label');
  // FIX: Prüfen, ob das Ziel eines der Steuerelemente ODER der Verbindungs-Button ist
  const isControlElement = target.closest('.conceptmap #addNode, .conceptmap #deleteMode, .conceptmap #clearAll, .conceptmap .color-button, .node-connect-btn');

  // Nur zurücksetzen, wenn die Berührung außerhalb ALLER interaktiven Elemente liegt
  if (!isCanvasElement && !isNodeElement && !isLabelElement && !isControlElement) {
    // Vollständiger Reset aller Interaktionszustände
    isSelecting = false;
    clearTimeout(selectTimeout);
    connectStart = null;
    draggedNode = null;
    draggedControl = null;
    potentialDraggedControl = null;
    hasMoved = false;

    if (selectedNode) {
      selectedNode.element.classList.remove('selected');
      selectedNode.connectBtn.style.display = 'none';
      selectedNode = null;
    }
    if (selectedConnection) {
      selectedConnection = null;
      renderConnections();
    }
  }
}, { passive: true });

  // Node erstellen
  function createNode(x, y, text = 'Neues Element', id = null, backgroundColor = 'white') {
    const node = document.createElement('div');
    node.className = 'node';
    node.style.left = x + 'px';
    node.style.top = y + 'px';
    node.style.backgroundColor = backgroundColor;
    node.style.zIndex = '10';
    node.style.maxWidth = '200px';
    node.style.wordWrap = 'break-word';
    node.style.overflowWrap = 'break-word';
    
    const nodeText = document.createElement('div');
    nodeText.className = 'node-text';
    nodeText.textContent = text;
    nodeText.style.width = '100%';
    nodeText.style.wordWrap = 'break-word';
    nodeText.style.overflowWrap = 'break-word';
    nodeText.style.whiteSpace = 'normal';
    nodeText.style.lineHeight = '1.2';
    nodeText.style.padding = '8px';
    node.appendChild(nodeText);

    const connectBtn = document.createElement('button');
    connectBtn.setAttribute('type', 'button');
    connectBtn.className = 'node-connect-btn';
    connectBtn.textContent = '+';
    connectBtn.title = 'Verbindung erstellen';
    canvas.appendChild(connectBtn);

    const nodeData = {
      id: id || nodeIdCounter++,
      element: node,
      connectBtn: connectBtn,
      x: x,
      y: y,
      backgroundColor: backgroundColor
    };
    
    nodes.push(nodeData);
    canvas.appendChild(node);

    function updateConnectBtnPosition() {
      const rect = node.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      connectBtn.style.left = `${rect.right - canvasRect.left}px`;
      connectBtn.style.top = `${rect.top - canvasRect.top - 18}px`;
    }
    updateConnectBtnPosition();
    node.addEventListener('mousemove', updateConnectBtnPosition);
    window.addEventListener('resize', updateConnectBtnPosition);

    connectBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      handleConnect(nodeData);
    });

    node.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      draggedNode = nodeData;
      hasMoved = false;
      dragStartPos.x = e.clientX;
      dragStartPos.y = e.clientY;
    }, { passive: true });

    node.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!hasMoved) {
        selectNode(nodeData);
        if (connectStart && connectStart !== nodeData) {
          handleConnect(nodeData);
        }
      }
    });

    node.addEventListener('dblclick', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('Doppelklick auf Node (Mouse):', nodeData.id);
      selectAndEditNode(nodeData);
    });

    let nodeLastTap = 0;
    node.addEventListener('touchstart', (e) => {
      e.stopPropagation();
      const touch = e.touches[0];
      const currentTime = Date.now();
      const tapLength = currentTime - nodeLastTap;
      if (tapLength < 500 && tapLength > 0) {
        console.log('Double-Tap auf Node (Touch):', nodeData.id);
        selectAndEditNode(nodeData);
      } else {
        draggedNode = nodeData;
        hasMoved = false;
        dragStartPos.x = touch.clientX;
        dragStartPos.y = touch.clientY;

        const touchMoveHandler = createTouchDragHandler(true);
        const touchEndHandler = createTouchEndHandler();
        document.addEventListener('touchmove', touchMoveHandler, { passive: false });
        document.addEventListener('touchend', touchEndHandler, { passive: true });

        const globalTouchEnd = () => {
          document.removeEventListener('touchmove', touchMoveHandler);
          document.removeEventListener('touchend', touchEndHandler);
          document.removeEventListener('touchend', globalTouchEnd);
        };
        document.addEventListener('touchend', globalTouchEnd, { once: true });
      }
      nodeLastTap = currentTime;
    }, { passive: false });

    return nodeData;
  }

  // Node auswählen
  function selectNode(nodeData) {
    if (selectedNode && selectedNode !== nodeData) {
      selectedNode.element.classList.remove('selected');
      selectedNode.connectBtn.style.display = 'none';
    }
    selectedNode = nodeData;
    nodeData.element.classList.add('selected');
    nodeData.connectBtn.style.display = 'block';
    selectedConnection = null;
    renderConnections();
  }

  // Node auswählen und editieren
  function selectAndEditNode(nodeData) {
    console.log('selectAndEditNode aufgerufen für Node:', nodeData.id);
    selectNode(nodeData);

    if (connectStart) {
      connectStart.element.classList.remove('connecting');
      connectStart = null;
      canvas.classList.remove('connecting');
    }

    const nodeText = nodeData.element.querySelector('.node-text');
    const rect = nodeText.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();

    nodeText.style.visibility = 'hidden';

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'node-text-input';
    input.value = nodeText.textContent || '';
    input.maxLength = 200;
    input.style.position = 'absolute';
    input.style.left = `${rect.left - canvasRect.left}px`;
    input.style.top = `${rect.top - canvasRect.top}px`;
    input.style.width = `${rect.width}px`;
    input.style.height = `${rect.height}px`;
    input.style.border = 'none';
    input.style.background = 'transparent';
    input.style.font = window.getComputedStyle(nodeText).font;
    input.style.textAlign = window.getComputedStyle(nodeText).textAlign;
    input.style.padding = '0';
    input.style.margin = '0';
    input.style.zIndex = '20';
    canvas.appendChild(input);

    input.focus();
    input.select();

    input.addEventListener('input', (e) => {
      if (input.value.length >= input.maxLength) {
        alert(`Maximale Länge von ${input.maxLength} Zeichen erreicht!`);
      }
    });

    const saveInput = () => {
      nodeText.textContent = input.value.trim();
      input.remove();
      nodeText.style.visibility = 'visible';
      saveToJSON();
    };

    input.addEventListener('blur', saveInput);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      }
    });

    nodeData.element.addEventListener('dblclick', (e) => {
      e.stopPropagation();
    }, { once: true });
  }

  // Verbindung starten oder erstellen
  function handleConnect(nodeData) {
    if (!connectStart) {
      connectStart = nodeData;
      nodeData.element.classList.add('connecting');
      canvas.classList.add('connecting');
    } else {
      if (connectStart.id !== nodeData.id) {
        const fromRect = connectStart.element.getBoundingClientRect();
        const toRect = nodeData.element.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
        const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
        const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
        const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

        const startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect) || {x: x1, y: y1};
        const endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect) || {x: x2, y: y2};

        const controlX = (startPoint.x + endPoint.x) / 2;
        const controlY = (startPoint.y + endPoint.y) / 2;

        createConnection(connectStart, nodeData, '', controlX, controlY);
      }
      connectStart.element.classList.remove('connecting');
      canvas.classList.remove('connecting');
      connectStart = null;
    }
  }

  function createConnection(from, to, label = '', controlX, controlY, id = null) {
    const conn = {
      id: id || connectionIdCounter++,
      from: from.id,
      to: to.id,
      label: label,
      labelElement: null,
      controlX: controlX,
      controlY: controlY,
      isDragging: false
    };
    connections.push(conn);
    renderConnections();
    saveToJSON();
  }

  // Verbindungen zeichnen
  function renderConnections() {
    while (svg.children.length > 1) {
      svg.removeChild(svg.lastChild);
    }

    connections.forEach(conn => {
      const fromNode = nodes.find(n => n.id === conn.from);
      const toNode = nodes.find(n => n.id === conn.to);
      
      if (!fromNode || !toNode) return;

      const fromRect = fromNode.element.getBoundingClientRect();
      const toRect = toNode.element.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();

      const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
      const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
      const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
      const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

      let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect);
      if (!startPoint) startPoint = {x: x1, y: y1};
      let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect);
      if (!endPoint) endPoint = {x: x2, y: y2};

      const startX = startPoint.x;
      const startY = startPoint.y;
      const endX = endPoint.x;
      const endY = endPoint.y;
      const controlX = conn.controlX;
      const controlY = conn.controlY;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const d = `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`;
      path.setAttribute('d', d);
      path.setAttribute('class', 'connection');
      if (selectedConnection === conn) {
        path.classList.add('selected');
      }
  path.addEventListener('click', (e) => {
  e.preventDefault();  // FIX: Verhindert Safari's synthetische Events
  e.stopPropagation();
  if (!isSelecting && !hasMoved) {  // FIX: Zusätzlicher Check
    selectConnection(conn);
  }
});
      svg.appendChild(path);

      const t = 0.5;
      const labelX = (1 - t) ** 2 * startX + 2 * (1 - t) * t * controlX + t ** 2 * endX;
      const labelY = (1 - t) ** 2 * startY + 2 * (1 - t) * t * controlY + t ** 2 * endY;

      if (!conn.labelElement) {
        const labelDiv = document.createElement('div');
        labelDiv.className = 'connection-label';
        labelDiv.textContent = conn.label || '';
        if (!conn.label) labelDiv.classList.add('empty');
        labelDiv.style.left = `${labelX - 50}px`;
        labelDiv.style.top = `${labelY - 10}px`;
        canvas.appendChild(labelDiv);
        conn.labelElement = labelDiv;
        attachLabelEvents(labelDiv, conn);
      } else {
        conn.labelElement.style.left = `${labelX - 50}px`;
        conn.labelElement.style.top = `${labelY - 10}px`;
        if (conn.labelElement.tagName === 'DIV') {
          conn.labelElement.textContent = conn.label || '';
          if (!conn.label) {
            conn.labelElement.classList.add('empty');
          } else {
            conn.labelElement.classList.remove('empty');
          }
        }
      }
    });
  }

function selectConnection(conn) {
  isSelecting = true;
  clearTimeout(selectTimeout);
  selectTimeout = setTimeout(() => {
    isSelecting = false;
  }, 300);

  // FIX: Sofort Drags resetten, um Leaks zu verhindern
  potentialDraggedControl = null;
  draggedControl = null;
  hasMoved = false;

  selectedConnection = conn;
  if (selectedNode) {
    selectedNode.element.classList.remove('selected');
    selectedNode.connectBtn.style.display = 'none';
    selectedNode = null;
  }
  renderConnections();
}

  function deleteNode(nodeData) {
    const connectionsToDelete = connections.filter(c => c.from === nodeData.id || c.to === nodeData.id);
    connectionsToDelete.forEach(c => {
      if (c.labelElement) {
        c.labelElement.remove();
      }
    });
    connections = connections.filter(c => c.from !== nodeData.id && c.to !== nodeData.id);
    nodes = nodes.filter(n => n.id !== nodeData.id);
    nodeData.element.remove();
    nodeData.connectBtn.remove();
    renderConnections();
    saveToJSON();
  }

  function deleteConnection(conn) {
    if (conn.labelElement) {
      conn.labelElement.remove();
    }
    connections = connections.filter(c => c.id !== conn.id);
    renderConnections();
    saveToJSON();
  }

  document.addEventListener('mousemove', (e) => {
    if (draggedNode) {
      const deltaX = Math.abs(e.clientX - dragStartPos.x);
      const deltaY = Math.abs(e.clientY - dragStartPos.y);
      
      if (deltaX > 5 || deltaY > 5) {
        hasMoved = true;
        const canvasRect = canvas.getBoundingClientRect();
        const nodeRect = draggedNode.element.getBoundingClientRect();
        let newX = e.clientX - canvasRect.left - (nodeRect.width / 2);
        let newY = e.clientY - canvasRect.top - (nodeRect.height / 2);

        newX = Math.max(0, Math.min(newX, canvasRect.width - nodeRect.width));
        newY = Math.max(0, Math.min(newY, canvasRect.height - nodeRect.height));

        draggedNode.x = newX;
        draggedNode.y = newY;
        draggedNode.element.style.left = newX + 'px';
        draggedNode.element.style.top = newY + 'px';
        const rect = draggedNode.element.getBoundingClientRect();
        draggedNode.connectBtn.style.left = `${rect.right - canvasRect.left}px`;
        draggedNode.connectBtn.style.top = `${rect.top - canvasRect.top - 18}px`;
        renderConnections();
      }
    } else if (draggedControl) {
      const deltaX = Math.abs(e.clientX - dragStartPos.x);
      const deltaY = Math.abs(e.clientY - dragStartPos.y);
      
      if (deltaX > 5 || deltaY > 5) {
        draggedControl.isDragging = true;
        const canvasRect = canvas.getBoundingClientRect();
        let newX = e.clientX - canvasRect.left;
        let newY = e.clientY - canvasRect.top;

        newX = Math.max(0, Math.min(newX, canvasRect.width));
        newY = Math.max(0, Math.min(newY, canvasRect.height));

        const fromNode = nodes.find(n => n.id === draggedControl.from);
        const toNode = nodes.find(n => n.id === draggedControl.to);
        if (fromNode && toNode) {
          const fromRect = fromNode.element.getBoundingClientRect();
          const toRect = toNode.element.getBoundingClientRect();
          const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
          const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
          const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
          const y2 = toRect.top + toRect.height / 2 - canvasRect.top;
          
          let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect) || {x: x1, y: y1};
          let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect) || {x: x2, y: y2};

          const t = 0.5;
          draggedControl.controlX = (newX - (1 - t) ** 2 * startPoint.x - t ** 2 * endPoint.x) / (2 * (1 - t) * t);
          draggedControl.controlY = (newY - (1 - t) ** 2 * startPoint.y - t ** 2 * endPoint.y) / (2 * (1 - t) * t);
        }

        dragStartPos.x = e.clientX;
        dragStartPos.y = e.clientY;
        renderConnections();
        saveToJSON();
      }
    } else if (potentialDraggedControl) {
      const deltaX = Math.abs(e.clientX - dragStartPos.x);
      const deltaY = Math.abs(e.clientY - dragStartPos.y);
      
      if (deltaX > 5 || deltaY > 5) {
        hasMoved = true;
        draggedControl = potentialDraggedControl;
        potentialDraggedControl = null;
        draggedControl.isDragging = true;
        const canvasRect = canvas.getBoundingClientRect();
        let newX = e.clientX - canvasRect.left;
        let newY = e.clientY - canvasRect.top;

        newX = Math.max(0, Math.min(newX, canvasRect.width));
        newY = Math.max(0, Math.min(newY, canvasRect.height));

        const fromNode = nodes.find(n => n.id === draggedControl.from);
        const toNode = nodes.find(n => n.id === draggedControl.to);
        if (fromNode && toNode) {
          const fromRect = fromNode.element.getBoundingClientRect();
          const toRect = toNode.element.getBoundingClientRect();
          const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
          const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
          const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
          const y2 = toRect.top + toRect.height / 2 - canvasRect.top;
          
          let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect) || {x: x1, y: y1};
          let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect) || {x: x2, y: y2};

          const t = 0.5;
          draggedControl.controlX = (newX - (1 - t) ** 2 * startPoint.x - t ** 2 * endPoint.x) / (2 * (1 - t) * t);
          draggedControl.controlY = (newY - (1 - t) ** 2 * startPoint.y - t ** 2 * endPoint.y) / (2 * (1 - t) * t);
        }

        dragStartPos.x = e.clientX;
        dragStartPos.y = e.clientY;
        renderConnections();
      }
    }
  });

  document.addEventListener('mouseup', () => {
    if (draggedNode) {
      if (hasMoved) {
        saveToJSON();
      }
      draggedNode = null;
      hasMoved = false;
    }
    if (draggedControl) {
      if (draggedControl.isDragging) {
        saveToJSON();
      }
      draggedControl.isDragging = false;
      draggedControl = null;
    }
    potentialDraggedControl = null;
  });

  // Canvas-Events: Double-Click für neuen Node (Mouse) und Double-Tap (Touch)
  canvas.addEventListener('dblclick', (e) => {
    if (e.target === canvas || e.target === svg) {
      const rect = canvas.getBoundingClientRect();
      createNode(e.clientX - rect.left - 50, e.clientY - rect.top - 20);
      saveToJSON();
    }
  });

  // Touch für Canvas: Double-Tap zum Hinzufügen
  let canvasLastTap = 0;
  canvas.addEventListener('touchstart', (e) => {
    if (e.target === canvas || e.target === svg) {
      const currentTime = Date.now();
      const tapLength = currentTime - canvasLastTap;
      hasMoved = false;
      dragStartPos.x = e.touches[0].clientX;
      dragStartPos.y = e.touches[0].clientY;

      if (tapLength < 500 && tapLength > 0) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        createNode(touch.clientX - rect.left - 50, touch.clientY - rect.top - 20);
        saveToJSON();
      } else {
        const touchMoveHandler = (e) => {
          const touch = e.touches[0];
          const deltaX = Math.abs(touch.clientX - dragStartPos.x);
          const deltaY = Math.abs(touch.clientY - dragStartPos.y);

          if (deltaX > 5 || deltaY > 5) {
            hasMoved = true;
          }
        };

        const touchEndHandler = (e) => {
          document.removeEventListener('touchmove', touchMoveHandler);
          document.removeEventListener('touchend', touchEndHandler);
        };

        document.addEventListener('touchmove', touchMoveHandler, { passive: true });
        document.addEventListener('touchend', touchEndHandler, { passive: true });
      }
      canvasLastTap = currentTime;
    }
  }, { passive: true });

  canvas.addEventListener('touchend', (e) => {
    if (e.target === canvas || e.target === svg) {
      if (!hasMoved) {
        if (selectedNode) {
          selectedNode.element.classList.remove('selected');
          selectedNode.connectBtn.style.display = 'none';
          selectedNode = null;
        }
        selectedConnection = null;
        if (connectStart) {
          connectStart.element.classList.remove('connecting');
          canvas.classList.remove('connecting');
          connectStart = null;
        }
        renderConnections();
      }
      hasMoved = false;
    }
  }, { passive: true });

  document.querySelector('.conceptmap #addNode').addEventListener('click', () => {
    const canvasRect = canvas.getBoundingClientRect();
    const centerX = (canvasRect.width / 10) - 50;
    const centerY = (canvasRect.height / 10) - 20;
    createNode(centerX, centerY);
    saveToJSON();
  });
document.querySelector('.conceptmap #deleteMode').addEventListener('click', () => {
  // FIX: Reset Flag vor Löschung
  isSelecting = false;
  clearTimeout(selectTimeout);
  if (selectedNode) {
    deleteNode(selectedNode);
    selectedNode = null;
  } else if (selectedConnection) {
    deleteConnection(selectedConnection);
    selectedConnection = null;
  } else {
    alert('Bitte erst ein Element anklicken, dann Löschen drücken.');
  }
});
  document.querySelector('.conceptmap #clearAll').addEventListener('click', () => {
    if (confirm('Wirklich alles löschen?')) {
      nodes.forEach(n => {
        n.element.remove();
        n.connectBtn.remove();
      });
      connections.forEach(c => {
        if (c.labelElement) c.labelElement.remove();
      });
      nodes = [];
      connections = [];
      nodeIdCounter = 1;
      connectionIdCounter = 1;
      renderConnections();
      saveToJSON();
    }
  });

  document.querySelectorAll('.conceptmap .color-button').forEach(button => {
    button.addEventListener('click', () => {
      if (selectedNode) {
        const color = button.getAttribute('data-color');
        selectedNode.element.style.backgroundColor = color;
        selectedNode.backgroundColor = color;
        saveToJSON();
      } else {
        alert('Bitte erst ein Element auswählen.');
      }
    });
  });

  function saveToJSON() {
    const data = {
      nodes: nodes.map(n => ({
        id: n.id,
        x: n.x,
        y: n.y,
        text: n.element.querySelector('.node-text').textContent,
        backgroundColor: n.backgroundColor
      })),
      connections: connections.map(c => ({
        id: c.id,
        from: c.from,
        to: c.to,
        label: c.label,
        controlX: c.controlX,
        controlY: c.controlY
      }))
    };
    jsonInput.value = JSON.stringify(data);
  }

  function loadFromJSON(jsonStr) {
    try {
      const data = JSON.parse(jsonStr);
      
      nodes.forEach(n => {
        n.element.remove();
        n.connectBtn.remove();
      });
      connections.forEach(c => {
        if (c.labelElement) c.labelElement.remove();
      });
      nodes = [];
      connections = [];
      
      if (data.nodes) {
        data.nodes.forEach(n => {
          createNode(n.x, n.y, n.text, n.id, n.backgroundColor);
          if (n.id >= nodeIdCounter) nodeIdCounter = n.id + 1;
        });
      }
      
      if (data.connections) {
        data.connections.forEach(c => {
          const from = nodes.find(n => n.id === c.from);
          const to = nodes.find(n => n.id === c.to);
          if (from && to) {
            createConnection(from, to, c.label, c.controlX, c.controlY, c.id);
            if (c.id >= connectionIdCounter) connectionIdCounter = c.id + 1;
          }
        });
      }
      
      renderConnections();
    } catch (e) {
      alert('Fehler beim Laden: Ungültiges JSON-Format');
    }
  }

   canvas.addEventListener('click', (e) => {
    if (e.target === canvas || e.target === svg) {
      // FIX: isSelecting-Timeout hier auch zurücksetzen
      isSelecting = false;
      clearTimeout(selectTimeout);

      if (selectedNode) {
        selectedNode.element.classList.remove('selected');
        selectedNode.connectBtn.style.display = 'none';
        selectedNode = null;
      }
      selectedConnection = null;
      if (connectStart) {
        connectStart.element.classList.remove('connecting');
        canvas.classList.remove('connecting');
        connectStart = null;
      }
      renderConnections();
    }
  });

  function attachLabelEvents(element, conn) {
    let labelLastTap = 0;

    const editLabel = (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'connection-label-input';
      input.value = conn.label || '';
      input.maxLength = 50;
      input.style.left = element.style.left;
      input.style.top = element.style.top;
      canvas.appendChild(input);
      conn.labelElement = input;
      element.remove();

      input.focus();
      input.select();

      input.addEventListener('input', (e) => {
        if (input.value.length >= input.maxLength) {
          alert(`Maximale Länge von ${input.maxLength} Zeichen erreicht!`);
        }
      });

      const saveInput = () => {
        conn.label = input.value.trim();
        const newLabelDiv = document.createElement('div');
        newLabelDiv.className = 'connection-label';
        newLabelDiv.textContent = conn.label || '';
        if (!conn.label) newLabelDiv.classList.add('empty');
        newLabelDiv.style.left = input.style.left;
        newLabelDiv.style.top = input.style.top;
        canvas.appendChild(newLabelDiv);
        conn.labelElement = newLabelDiv;
        input.remove();
        saveToJSON();
        attachLabelEvents(newLabelDiv, conn);
      };

      input.addEventListener('blur', saveInput);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.blur();
        }
      });
    };

    // Mouse-Events für Label (Desktop)
    element.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      if (draggedNode) {
        draggedNode = null;
      }
      if (isSelecting) {
        return;
      }
      potentialDraggedControl = conn;
      hasMoved = false;
      dragStartPos.x = e.clientX;
      dragStartPos.y = e.clientY;
    });

    element.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!hasMoved && !isSelecting) {
        selectConnection(conn);
      }
    });

    element.addEventListener('dblclick', (e) => {
      e.preventDefault();
      e.stopPropagation();
      editLabel(e);
    });

    // Touch-Events für Label (iOS/Mobile)
    element.addEventListener('touchstart', (e) => {
      // FIX: Wichtig, um Safari's Touch-to-Mouse-Konvertierung zu verhindern
      e.preventDefault(); 
      if (draggedControl) {
        draggedControl = null;
      }
      if (draggedNode) {
        draggedNode = null;
      }
      const touch = e.touches[0];
      const currentTime = Date.now();
      const tapLength = currentTime - labelLastTap;
      if (tapLength < 500 && tapLength > 0) {
        editLabel(e);
      } else {
        if (isSelecting) {
          return;
        }
        potentialDraggedControl = conn;
        hasMoved = false;
        dragStartPos.x = touch.clientX;
        dragStartPos.y = touch.clientY;

        const touchMoveHandler = createTouchDragHandler(false);
        const touchEndHandler = (e) => {
          if (!hasMoved) {
            selectConnection(conn);
          }
          document.removeEventListener('touchmove', touchMoveHandler);
          document.removeEventListener('touchend', touchEndHandler);
        };

        document.addEventListener('touchmove', touchMoveHandler, { passive: false });
        document.addEventListener('touchend', touchEndHandler, { passive: true });

        const globalTouchEnd = () => {
          document.removeEventListener('touchmove', touchMoveHandler);
          document.removeEventListener('touchend', touchEndHandler);
          document.removeEventListener('touchend', globalTouchEnd);
        };
        document.addEventListener('touchend', globalTouchEnd, { once: true });
      }
      labelLastTap = currentTime;
    }, { passive: false });
  } 
</script>
