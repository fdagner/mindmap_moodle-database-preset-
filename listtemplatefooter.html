         </tbody>
            </table>
        </div>
    </div>
</div>

<script>
    // Globale Variablen für das kombinierte Diagramm
    const combinedSvg = document.getElementById('combinedChart');
    const height = 600;
    const margin = { top: 60, right: 100, bottom: 60, left: 70 };
    const plotHeight = height - margin.top - margin.bottom;

    const plotGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    plotGroup.setAttribute('transform', `translate(${margin.left},${margin.top})`);
    combinedSvg.appendChild(plotGroup);

    const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const xAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const yAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    plotGroup.appendChild(gridGroup);
    plotGroup.appendChild(pointsGroup);
    plotGroup.appendChild(xAxisGroup);
    plotGroup.appendChild(yAxisGroup);
    plotGroup.appendChild(legendGroup);

    // Hilfsfunktionen
    function timeToMinutes(timeStr) {
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + m;
    }

    // Alle Daten sammeln: Array von Objekten {name, color, observations: [{time, engagement, text}]}
    const groups = [];
    document.querySelectorAll('#entryTableBody tr').forEach(row => {
        const nameCell = row.querySelector('td:nth-child(1)');
        const colorCell = row.querySelector('td:nth-child(2) code');
        const jsonSpan = row.querySelector('td:nth-child(3) span.observation');

        if (nameCell && colorCell && jsonSpan) {
            const name = nameCell.textContent.trim();
            const color = colorCell.textContent.trim();
            let observations = [];
            try {
                const jsonText = jsonSpan.textContent.trim();
                if (jsonText && jsonText !== '[]') {
                    observations = JSON.parse(jsonText);
                }
            } catch (e) {
                console.error('Ungültiges JSON in Gruppe ' + name, e);
            }

            // Anzahl in die Tabelle schreiben
            row.querySelector('td:nth-child(3)').innerHTML = observations.length;

            if (observations.length > 0) {
                groups.push({ name, color, observations });
            }
        }
    });

    // Wenn keine Daten vorhanden → leeres Diagramm
    if (groups.length === 0) {
        combinedSvg.setAttribute('width', 900);
        const noDataText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        noDataText.setAttribute('x', 450);
        noDataText.setAttribute('y', 300);
        noDataText.setAttribute('text-anchor', 'middle');
        noDataText.setAttribute('font-size', '20');
        noDataText.textContent = 'Noch keine Beobachtungen vorhanden';
        combinedSvg.appendChild(noDataText);
    }

    // Alle Beobachtungen sammeln für Zeitbereich
    const allObservations = [];
    groups.forEach(group => {
        group.observations.forEach(obs => {
            allObservations.push({
                time: obs.time,
                engagement: obs.engagement,
                text: obs.text || '',      
                color: group.color,
                name: group.name
            });
        });
    });

    const minutesArray = allObservations.map(o => timeToMinutes(o.time));
    let minMinutes = Math.min(...minutesArray) - 5;
    let maxMinutes = Math.max(...minutesArray) + 5;
    minMinutes = Math.floor(minMinutes / 5) * 5;
    maxMinutes = Math.ceil(maxMinutes / 5) * 5;

    const totalMinutes = maxMinutes - minMinutes;
    const pixelsPer10Min = 250; // Gleiche Skalierung wie in der Einzelansicht
    let plotWidth = totalMinutes * (pixelsPer10Min / 10);
    plotWidth = Math.max(plotWidth, 840); // Mindestbreite

    const width = plotWidth + margin.left + margin.right;
    combinedSvg.setAttribute('width', width);

    // Skalierungsfunktionen
    const xScale = m => (m - minMinutes) / totalMinutes * plotWidth;
    const yScale = v => plotHeight - ((v + 5) / 110) * plotHeight;

    // Gitter und Achsen zeichnen
    gridGroup.innerHTML = '';
    xAxisGroup.innerHTML = '';
    yAxisGroup.innerHTML = '';

    // X-Achse (Zeit) – Gitterlinien und Beschriftung alle 10 Min
    xAxisGroup.setAttribute('transform', `translate(0,${plotHeight})`);
    for (let m = minMinutes; m <= maxMinutes; m += 5) {
        const x = xScale(m);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x); line.setAttribute('y1', 0);
        line.setAttribute('x2', x); line.setAttribute('y2', plotHeight);
        line.setAttribute('stroke', '#eee');
        gridGroup.appendChild(line);

        if (m % 10 === 0) {
            const h = String(Math.floor(m / 60)).padStart(2, '0');
            const min = String(m % 60).padStart(2, '0');
            const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            txt.setAttribute('x', x); txt.setAttribute('y', 20);
            txt.setAttribute('text-anchor', 'middle');
            txt.setAttribute('font-size', '12');
            txt.textContent = `${h}:${min}`;
            xAxisGroup.appendChild(txt);
        }
    }

    // Y-Achse (Engagement %)
    for (let p = 0; p <= 100; p += 10) {
        const y = yScale(p);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0); line.setAttribute('y1', y);
        line.setAttribute('x2', plotWidth); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#eee');
        gridGroup.appendChild(line);

        const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        txt.setAttribute('x', -10); txt.setAttribute('y', y + 5);
        txt.setAttribute('text-anchor', 'end');
        txt.setAttribute('font-size', '12');
        txt.textContent = p;
        yAxisGroup.appendChild(txt);
    }

    // Y-Label
    if (!combinedSvg.querySelector('text[data-ylabel]')) {
        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('x', -plotHeight / 2 - margin.top);
        yLabel.setAttribute('y', -45);
        yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('font-size', '16');
        yLabel.setAttribute('data-ylabel', 'true');
        yLabel.textContent = 'Engagement (%)';
        combinedSvg.appendChild(yLabel);
    }

        // Punkte zeichnen – mit Klick → Modal
     // === CLUSTERING FÜR DIE LISTENANSICHT ===
    pointsGroup.innerHTML = '';

    // Gruppierung nach exakt gleicher Position: time + engagement
    const clusters = {};
    allObservations.forEach(obs => {
        const key = `${obs.time}|${obs.engagement}`;
        if (!clusters[key]) clusters[key] = [];
        clusters[key].push(obs);
    });

    let expandedCluster = null; // Nur ein Cluster gleichzeitig expandiert

    Object.values(clusters).forEach(clusterObservations => {
        const firstObs = clusterObservations[0];
        const cx = xScale(timeToMinutes(firstObs.time));
        const cy = yScale(firstObs.engagement);

        if (clusterObservations.length === 1) {
            // Einzelner Punkt
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', cx);
            circle.setAttribute('cy', cy);
            circle.setAttribute('r', 12);
            circle.setAttribute('fill', firstObs.color);
            circle.setAttribute('stroke', '#000');
            circle.setAttribute('stroke-width', 2);
            circle.style.cursor = 'pointer';

            // Hover
            circle.addEventListener('mouseenter', () => circle.setAttribute('r', 15));
            circle.addEventListener('mouseleave', () => circle.setAttribute('r', 12));

            // Klick → Modal
            circle.addEventListener('click', (e) => {
                e.stopPropagation();
                openObservationDetail(clusterObservations[0]);
            });

            pointsGroup.appendChild(circle);
        } else {
            // Cluster: Roter Kreis mit Anzahl
            const clusterCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            clusterCircle.setAttribute('cx', cx);
            clusterCircle.setAttribute('cy', cy);
            clusterCircle.setAttribute('r', 16);
            clusterCircle.setAttribute('fill', '#dc3545');
            clusterCircle.setAttribute('opacity', '0.9');
            clusterCircle.style.cursor = 'pointer';

            const countText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            countText.setAttribute('x', cx);
            countText.setAttribute('y', cy + 5);
            countText.setAttribute('text-anchor', 'middle');
            countText.setAttribute('fill', 'white');
            countText.setAttribute('font-weight', 'bold');
            countText.setAttribute('font-size', '14');
            countText.textContent = clusterObservations.length;
            countText.style.pointerEvents = 'none';

            pointsGroup.appendChild(clusterCircle);
            pointsGroup.appendChild(countText);

            // Klick auf Cluster → Ausklappen
            clusterCircle.addEventListener('click', (e) => {
                e.stopPropagation();

                // Alten Cluster schließen
                if (expandedCluster) {
                    expandedCluster.remove();
                    expandedCluster = null;
                }

                // Neuen Cluster expandieren
                expandedCluster = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                pointsGroup.appendChild(expandedCluster);

                const radius = 60; // Abstand der ausgeklappten Punkte
                clusterObservations.forEach((obs, i) => {
                    const angle = (i / clusterObservations.length) * 2 * Math.PI - Math.PI / 2; // Oben beginnen
                    const px = cx + radius * Math.cos(angle);
                    const py = cy + radius * Math.sin(angle);

                    const p = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    p.setAttribute('cx', px);
                    p.setAttribute('cy', py);
                    p.setAttribute('r', 12);
                    p.setAttribute('fill', obs.color);
                    p.setAttribute('stroke', '#000');
                    p.setAttribute('stroke-width', 2);
                    p.style.cursor = 'pointer';

                    // Hover
                    p.addEventListener('mouseenter', () => p.setAttribute('r', 15));
                    p.addEventListener('mouseleave', () => p.setAttribute('r', 12));

                    // Klick → Modal mit dieser Beobachtung
                    p.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openObservationDetail(obs);
                    });

                    expandedCluster.appendChild(p);
                });

                // Klick außerhalb → Cluster schließen
                const closeHandler = (ev) => {
                    if (expandedCluster && !expandedCluster.contains(ev.target) && ev.target !== clusterCircle) {
                        expandedCluster.remove();
                        expandedCluster = null;
                        document.removeEventListener('click', closeHandler);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            });
        }
    });

    // Hilfsfunktion: Modal öffnen und befüllen
    function openObservationDetail(obs) {
        document.getElementById('detailGroupName').textContent = obs.name;
        document.getElementById('detailTime').value = obs.time;
        document.getElementById('detailSlider').value = obs.engagement;
        document.getElementById('detailValue').textContent = obs.engagement;
        document.getElementById('detailText').value = obs.text || '';

   

        // Modal öffnen (Moodle-sicher)
        const btn = document.createElement('button');
        btn.setAttribute('data-bs-toggle', 'modal');
        btn.setAttribute('data-bs-target', '#observationDetailModal');
        document.body.appendChild(btn);
        btn.click();
        document.body.removeChild(btn);
    }

// === VERBINDUNGSLINIEN PRO GRUPPE (gestrichelt) ===
groups.forEach(group => {
    // Beobachtungen dieser Gruppe nach Zeit sortieren
    const sortedObs = [...group.observations].sort((a, b) => 
        timeToMinutes(a.time) - timeToMinutes(b.time)
    );

    // Nur zeichnen, wenn mindestens 2 Punkte vorhanden sind
    if (sortedObs.length < 2) return;

    for (let i = 0; i < sortedObs.length - 1; i++) {
        const obs1 = sortedObs[i];
        const obs2 = sortedObs[i + 1];

        const x1 = xScale(timeToMinutes(obs1.time));
        const y1 = yScale(obs1.engagement);
        const x2 = xScale(timeToMinutes(obs2.time));
        const y2 = yScale(obs2.engagement);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', group.color);
        line.setAttribute('stroke-width', 2);
        line.setAttribute('stroke-dasharray', '6 4'); // gestrichelt: 6px Strich, 4px Lücke
        line.setAttribute('opacity', '0.7');          // etwas transparenter als Punkte
        line.setAttribute('pointer-events', 'none');  // Klicks gehen durch die Linie durch

        pointsGroup.insertBefore(line, pointsGroup.firstChild); 
        // Linien zuerst einfügen → liegen hinter den Punkten
    }
});

 // === LEGENDE (nach unten, horizontal, nicht abgeschnitten) ===
// Zuerst die Höhe des Diagramms berechnen und SVG anpassen
const legendRowHeight = 40; // Höhe pro Zeile (inkl. Abstand)
const maxItemsPerRow = 6;   // z. B. max. 6 Einträge pro Zeile, dann Umbruch
const numRows = Math.ceil(groups.length / maxItemsPerRow);
const legendHeight = numRows * legendRowHeight + 20; // +20 für unteren Rand

// SVG-Höhe erhöhen (ursprüngliche Höhe + Legendenhöhe)
combinedSvg.setAttribute('height', height + legendHeight);

// Legende positionieren
legendGroup.innerHTML = '';
legendGroup.setAttribute('transform', `translate(0, ${plotHeight + 60})`); // 60px Abstand unter X-Achse

groups.forEach((group, i) => {
    const col = i % maxItemsPerRow;
    const row = Math.floor(i / maxItemsPerRow);
    
    const x = col * 160; // 160px Abstand pro Eintrag (anpassen falls nötig)
    const y = row * legendRowHeight;

    // Farbkästchen
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', x);
    rect.setAttribute('y', y);
    rect.setAttribute('width', 20);
    rect.setAttribute('height', 20);
    rect.setAttribute('fill', group.color);
    rect.setAttribute('stroke', '#000');
    legendGroup.appendChild(rect);

    // Text
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', x + 30);
    text.setAttribute('y', y + 15);
    text.setAttribute('font-size', '14');
    text.textContent = group.name + ` (${group.observations.length})`;
    legendGroup.appendChild(text);
});



document.getElementById('exportCombinedSVG').addEventListener('click', () => {
        // Falls ein Cluster ausgeklappt ist → temporär entfernen
        if (typeof expandedCluster !== 'undefined' && expandedCluster) {
            expandedCluster.remove();
            expandedCluster = null;
        }

        // SVG serialisieren
        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(combinedSvg);

        // Nur xmlns hinzufügen, falls es noch nicht da ist
        if (!source.includes('xmlns="http://www.w3.org/2000/svg"')) {
            source = source.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
        }

        // Optional: Saubere Systemschrift für bessere Lesbarkeit in externen Programmen
        const style = `
            <style type="text/css">
                text { 
                    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
                    font-size: 12px;
                }
                line[stroke="#eee"] { stroke: #dddddd; }
            </style>`;
        source = source.replace('</svg>', style + '</svg>');

        // Download starten
        const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'alle-beobachtungen-engagement-diagramm.svg';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });
</script>