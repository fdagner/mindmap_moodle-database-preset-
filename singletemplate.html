<style>
    .node-action-overlay {
        display: none;
    }

    #color-##id## {
        background-color: #f8f9fa;
        border-color: #f8f9fa;
    }
</style>

<div class="main-content" id="fullscreen_mindmap">
    <h3>##actionsmenu##Mindmap von ##user##</h3>
    <div class="zoom-controls">
        <div class="mindmap">
            <div class="mindmap_buttons">
                <button type="button" class="btn btn-light toggle-editor-btn" onclick="toggleEditor()"
                    title="Listenmodus umschalten"><i class="fa-solid fa-list"></i></button>
                <button type="button" class="btn btn-light" onclick="zoomSvg(1.2)" title="Hineinzoomen"><i
                        class="fa-solid fa-magnifying-glass-plus"></i></button>
                <button type="button" class="btn btn-light" onclick="zoomSvg(1/1.2)" title="Herauszoomen"><i
                        class="fa-solid fa-magnifying-glass-minus"></i></button>
                <button type="button" class="btn btn-light" onclick="resetZoom()" title="Zoom zurücksetzen"><i
                        class="fa-solid fa-arrows-to-circle"></i></button>
                <button type="button" class="btn btn-light" onclick="toggleFullscreen()" title="Präsentationsmodus"><i
                        class="fa-solid fa-person-chalkboard"></i></button>
                <div class="dropdown">
                    <button class="btn btn-light dropdown-toggle" type="button" data-bs-toggle="dropdown"
                        aria-expanded="false" title="Mindmap exportieren">
                        <i class="fa-solid fa-file-export"></i>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a class="dropdown-item" href="#" onclick="exportAsSVG()">SVG</a></li>
                        <li><a class="dropdown-item" href="#" onclick="exportAsHTML()">Interaktives HTML</a></li>
                        <li><a class="dropdown-item" href="#" onclick="copyMermaidCode()">Mermaid</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <p id="color-##id##" style="display: none">[[color_theme]]</p>
        <div class="editor-panel" style="display: none;">
            <div id="mindmapEditor" class="mindmap-tree"></div>
            <div class="export-area" style="display: none;">
                <strong>Mermaid Code:</strong>
                <div id="import-area">[[mermaid_text]]</div>

                <input type="text" id="##id##" class="export-input nolink"
                    placeholder="Use ~ for each indentation level and | to separate nodes" value="">
            </div>
        </div>
        <div class="preview-panel">
            <div id="mermaidPreview" class="loading">
                <div id="welcomeMessage">
                    Klicke auf den Hauptknoten, um zu beginnen 😀...
                </div>
                <div id="svgZoomContainer"></div>
            </div>
        </div>
    </div>

    <div id="deleteModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Knoten löschen</h3>
            <p id="deleteModalMessage"></p>
            <div class="mindmap-modal-buttons" id="deleteModalButtons"></div>
        </div>
    </div>

    <div id="errorModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Fehler</h3>
            <p id="errorModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeErrorModal()">OK</button>
            </div>
        </div>
    </div>

    <div id="successModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Erfolg</h3>
            <p id="successModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeSuccessModal()">OK</button>
            </div>
        </div>
    </div>

    <div id="warningModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Warnung</h3>
            <p id="warningModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeWarningModal()">OK</button>
            </div>
        </div>
    </div>

    <script>
        let BRANCH_COLORS = BRANCH_COLORS_SCHEMES['Standard'].colors;
        const editor = document.getElementById('mindmapEditor');
        const previewContainer = document.getElementById('svgZoomContainer');
        const mermaidInput = document.getElementById('##id##');
        const welcomeMessage = document.getElementById('welcomeMessage');

        // Hole das Quell-div und das Ziel-input
        const sourceDiv = document.getElementById('import-area');
        const targetInput = document.getElementById('##id##');

        // Entferne HTML-Tags und hole den reinen Text
        const cleanText = sourceDiv.innerText;

        // Setze den bereinigten Text als value des input-Elements
        targetInput.value = cleanText;

        // Function for setting the color scheme
        function setColorScheme() {
            const colorElement = document.getElementById('color-##id##');
            let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';

            if (BRANCH_COLORS_SCHEMES[selectedScheme]) {
                BRANCH_COLORS = [...BRANCH_COLORS_SCHEMES[selectedScheme].colors];
            } else {
                BRANCH_COLORS = [...BRANCH_COLORS_SCHEMES['Standard'].colors];
            }

            renderEditor();
            renderMindmap();
        }

        // Function to show/hide the editor
        const toggleEditor = () => {
            const editorPanel = document.querySelector('.editor-panel');
            const previewPanel = document.querySelector('.preview-panel');
            const toggleButton = document.querySelector('.toggle-editor-btn');
            const zoomButtons = document.querySelectorAll('.zoom-controls .btn.btn-light:not(.toggle-editor-btn)');

            if (editorPanel.style.display === 'none') {
                editorPanel.style.display = 'block';
                previewPanel.style.display = 'none';
                toggleButton.innerHTML = '<i class="fa-solid fa-lightbulb"></i>';
                zoomButtons.forEach(button => button.style.display = 'none');
                if (welcomeMessage) welcomeMessage.style.display = 'none';
            } else {
                editorPanel.style.display = 'none';
                previewPanel.style.display = 'block';
                toggleButton.innerHTML = '<i class="fa-solid fa-list"></i>';
                zoomButtons.forEach(button => button.style.display = 'inline-block');
                if (welcomeMessage && !hasInteractedWithRoot && !mindmapData.some(node => node.parent !== null)) {
                    welcomeMessage.style.display = 'block';
                }
            }
        };

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            if (!editor || !previewContainer || !mermaidInput || !welcomeMessage) {
                console.error('Required DOM elements are missing:', {
                    mindmapEditor: !!editor,
                    svgZoomContainer: !!previewContainer,
                    mermaidInput: !!mermaidInput,
                    welcomeMessage: !!welcomeMessage
                });
                showErrorModal('Interner Fehler: Erforderliche DOM-Elemente fehlen. Bitte überprüfen Sie die HTML-Struktur.');
                mindmapData = [];
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block';
                return;
            }
            initializeFromMermaidCode();
            setColorScheme();
            renderMindmap();
        });

        // Zoom
        const zoomSvg = (factor) => {
            if (!previewContainer) return;
            currentZoom *= factor;
            previewContainer.style.transformOrigin = '0 0';
            previewContainer.style.transform = `scale(${currentZoom})`;
            document.getElementById('mermaidPreview').style.overflow = 'auto';
        };

        const resetZoom = () => {
            if (!previewContainer) return;
            currentZoom = 1;
            previewContainer.style.transform = 'none';
            document.getElementById('mermaidPreview').style.overflow = 'auto';
        };

        // Export as SVG
        const exportAsSVG = () => {
            const svgElement = document.getElementById('mermaidPreview').querySelector('svg');
            if (!svgElement) return showErrorModal('Keine Mindmap verfügbar. Bitte rendere die Mindmap zuerst.');
            const svgData = new XMLSerializer().serializeToString(svgElement.cloneNode(true));
            const svgBlob = new Blob(['<?xml version="1.0" standalone="no"?>\n' + svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(svgBlob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'mindmap.svg';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
            showSuccessModal('Mindmap wurde als SVG exportiert!');
        };

        // Modified export as HTML (removed zoom buttons)
        const exportAsHTML = () => {
            const svgElement = document.getElementById('mermaidPreview').querySelector('svg');
            if (!svgElement) return showErrorModal('Keine Mindmap verfügbar. Bitte rendere die Mindmap zuerst.');

            const svgData = new XMLSerializer().serializeToString(svgElement.cloneNode(true));
            const mindmapDataJson = JSON.stringify(mindmapData);
            const branchColorsJson = JSON.stringify(BRANCH_COLORS);
            const colorScheme = document.getElementById('color-##id##').innerText.trim() || 'Standard';
            const colorSchemeJson = JSON.stringify(BRANCH_COLORS_SCHEMES[colorScheme]);

            const htmlContent = `
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindmap Export</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background: #f8f9fa; 
            font-family: Inter, system-ui, sans-serif;
        }
        #svgContainer { 
            overflow: auto; 
            max-width: 100%; 
            max-height: 80vh; 
        }
        .node-rect, .node-text { cursor: pointer; }
    </style>
</head>
<body>
    <div id="svgContainer">${svgData}</div>
    <script>
        let mindmapData = ${mindmapDataJson};
        let BRANCH_COLORS = ${branchColorsJson};
        let BRANCH_COLORS_SCHEMES = { "${colorScheme}": ${colorSchemeJson} };

        function getContrastTextColor(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? '#000000' : '#ffffff';
        }

        function toggleCollapse(nodeId) {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.level !== 1) return;
            node.isCollapsed = !node.isCollapsed;
            renderMindmap();
        }

        function isNodeVisible(node) {
            if (node.level === 0) return true;
            const parent = mindmapData.find(n => n.id === node.parent);
            if (!parent) return false;
            if (parent.level === 1 && parent.isCollapsed) return false;
            return isNodeVisible(parent);
        }

        function buildTreeFromDataForSVG() {
            const nodesMap = new Map(mindmapData.map(node => [node.id, { ...node, children: [] }]));
            let root = null;
            nodesMap.forEach(node => {
                if (node.level === 0) root = node;
                if (node.parent !== null) {
                    const parent = nodesMap.get(node.parent);
                    if (parent && (parent.level !== 1 || !parent.isCollapsed)) {
                        parent.children.push(node);
                    }
                }
            });
            const sortChildren = node => {
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach(sortChildren);
            };
            if (root) sortChildren(root);
            return root;
        }

        function assignBranchColors(node) {
            const colorScheme = BRANCH_COLORS_SCHEMES["${colorScheme}"];
            node.color = node.level === 0 ? colorScheme.level0 :
                node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                    node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                        '#ffffff';
            node.textColor = getContrastTextColor(node.color);
            node.borderColor = node.level === 0 ? colorScheme.level0 : node.color;
            node.children.forEach(assignBranchColors);
        }

        function measureTextWidth(text, fontSize) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = \`\${fontSize}px Inter, system-ui, sans-serif\`;
            return ctx.measureText(text).width;
        }

        function splitLongWord(word, maxWidth, fontSize) {
            const chars = word.split('');
            let current = '';
            const result = [];
            chars.forEach(char => {
                const test = current + char;
                if (measureTextWidth(test, fontSize) > maxWidth) {
                    result.push(current);
                    current = char;
                } else {
                    current = test;
                }
            });
            if (current) result.push(current);
            return result;
        }

        function calculateSubtreeSize(node) {
            const fontSize = Math.max(12, 18 - node.level);
            const maxWidth = 200;
            const words = node.text.split(' ').flatMap(word => {
                if (measureTextWidth(word, fontSize) > maxWidth) {
                    return splitLongWord(word, maxWidth, fontSize);
                }
                return word;
            });
            let line = '';
            const lines = [];
            words.forEach(word => {
                const testLine = line + word + ' ';
                if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = testLine;
                }
            });
            if (line.length > 0) lines.push(line.trim());
            const lineHeight = fontSize * 1.2;
            node.height = lines.length * lineHeight + 20;
            node.width = Math.max(100, maxWidth + 20);
            if (!node.children.length) {
                node.subtreeWidth = node.width;
                node.subtreeHeight = node.height;
                return;
            }
            node.children.forEach(calculateSubtreeSize);
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            node.subtreeHeight = node.children.reduce((sum, child) => sum + child.subtreeHeight, 0) + Math.max(0, node.children.length - 1) * spacing;
            node.subtreeWidth = node.width + 100 + Math.max(...node.children.map(c => c.subtreeWidth));
        }

        function positionNode(node, x, y, direction) {
            if (typeof node.x === 'undefined') {
                node.x = direction === 'left' ? x - node.width : x;
            }
            node.y = y + (node.subtreeHeight - node.height) / 2;
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            let currentY = y;
            node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
            node.children.forEach(child => {
                const childDirection = child.direction || direction;
                const offset = 100;
                const childX = childDirection === 'right' ? node.x + node.width + offset : node.x - offset;
                positionNode(child, childX, currentY, childDirection);
                currentY += child.subtreeHeight + spacing;
            });
        }

        function calculateLayout(node, level = 0) {
            if (level === 0) {
                calculateSubtreeSize(node);
                let rightChildren = [];
                let leftChildren = [];
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach((child, index) => {
                    child.direction = index % 2 === 0 ? 'right' : 'left';
                    if (child.direction === 'right') rightChildren.push(child);
                    else leftChildren.push(child);
                });
                const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
                let rightTotalHeight = rightChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, rightChildren.length - 1) * spacing;
                let leftTotalHeight = leftChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, leftChildren.length - 1) * spacing;
                let maxTotalHeight = Math.max(leftTotalHeight, rightTotalHeight, node.height);
                node.x = Math.max(leftTotalHeight, rightTotalHeight) + 100;
                node.y = maxTotalHeight / 2 - node.height / 2;
                let rightY = node.y + node.height / 2 - rightTotalHeight / 2;
                rightChildren.forEach(child => {
                    positionNode(child, node.x + node.width + 100, rightY, 'right');
                    rightY += child.subtreeHeight + spacing;
                });
                let leftY = node.y + node.height / 2 - leftTotalHeight / 2;
                leftChildren.forEach(child => {
                    const rightEdgeX = node.x - 100;
                    positionNode(child, rightEdgeX, leftY, 'left');
                    leftY += child.subtreeHeight + spacing;
                });
            }
        }

        function getConnectionPoint(fromNode, toNode) {
            const fromCenterX = fromNode.x + fromNode.width / 2;
            const fromCenterY = fromNode.y + fromNode.height / 2;
            const toCenterX = toNode.x + toNode.width / 2;
            const toCenterY = toNode.y + toNode.height / 2;
            const dx = toCenterX - fromCenterX;
            const dy = toCenterY - fromCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            return {
                fromX: fromCenterX + normalizedDx * (fromNode.width / 2),
                fromY: fromCenterY + normalizedDy * (fromNode.height / 2),
                toX: toCenterX - normalizedDx * (toNode.width / 2),
                toY: toCenterY - normalizedDy * (toNode.height / 2)
            };
        }

        function getBounds(root) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const updateBounds = node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
                node.children.forEach(updateBounds);
            };
            updateBounds(root);
            return { minX, minY, maxX, maxY };
        }

        function generateSVG(root) {
            if (!root) return '';
            const padding = 100;
            assignBranchColors(root);
            calculateLayout(root);
            const { minX, minY, maxX, maxY } = getBounds(root);
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;
            let svg = \`<svg width="\${width}" height="\${height}" viewBox="\${minX - padding} \${minY - padding} \${width} \${height}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">\`;
            const drawConnections = node => {
                node.children.forEach(child => {
                    const { fromX, fromY, toX, toY } = getConnectionPoint(node, child);
                    svg += \`<line x1="\${fromX}" y1="\${fromY}" x2="\${toX}" y2="\${toY}" stroke="\${BRANCH_COLORS[child.branchIndex % BRANCH_COLORS.length] || '#667eea'}" stroke-width="2" stroke-linecap="round"/>\`;
                    drawConnections(child);
                });
            };
            const drawNodes = node => {
                const colorScheme = BRANCH_COLORS_SCHEMES["${colorScheme}"];
                const { fillColor, fillOpacity, strokeColor, strokeWidth, strokeDasharray } = node.level === 0
                    ? { fillColor: colorScheme.level0, strokeColor: colorScheme.level0, strokeWidth: 2, strokeDasharray: 'none' }
                    : node.level === 1
                        ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: 'none' }
                        : node.level === 2
                            ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], fillOpacity: '0.6', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' }
                            : { fillColor: '#ffffff', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' };
                const textColor = getContrastTextColor(fillColor);
                const originalNode = mindmapData.find(n => n.id === node.id);
                const hasChildren = mindmapData.some(n => n.parent === node.id);
                let collapseIndicator = '';
                if (node.level === 1 && hasChildren) {
                    const isCollapsed = originalNode && originalNode.isCollapsed;
                    const indicatorX = node.x + node.width - 15;
                    const indicatorY = node.y + 10;
                    collapseIndicator = \`<text x="\${indicatorX}" y="\${indicatorY}" font-size="12" font-family="Arial, sans-serif" fill="\${textColor}" text-anchor="middle">\${isCollapsed ? '+' : ''}\</text>\`;
                }
                svg += \`<rect data-node-id="\${node.id}" class="node-rect" x="\${node.x}" y="\${node.y}" width="\${node.width}" height="\${node.height}" rx="8" fill="\${fillColor}" fill-opacity="\${fillOpacity || '1'}" stroke="\${strokeColor}" stroke-width="\${strokeWidth}" stroke-dasharray="\${strokeDasharray}" style="cursor: \${node.level === 1 && hasChildren ? 'pointer' : 'default'}"/>\`;
                const words = node.text.split(' ').flatMap(word => {
                    const fontSize = Math.max(12, 18 - node.level);
                    if (measureTextWidth(word, fontSize) > 200) {
                        return splitLongWord(word, 200, fontSize);
                    }
                    return word;
                });
                let line = '';
                const lines = [];
                const maxWidth = 200;
                const fontSize = Math.max(12, 18 - node.level);
                words.forEach(word => {
                    const testLine = line + word + ' ';
                    if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                        lines.push(line.trim());
                        line = word + ' ';
                    } else {
                        line = testLine;
                    }
                });
                if (line.length > 0) lines.push(line.trim());
                const lineHeight = fontSize * 1.2;
                const totalTextHeight = lines.length * lineHeight;
                const startY = node.y + (node.height - totalTextHeight) / 2 + lineHeight * 0.7;
                lines.forEach((textLine, index) => {
                    svg += \`<text data-node-id="\${node.id}" class="node-text" x="\${node.x + node.width / 2}" y="\${startY + index * lineHeight}" font-size="\${fontSize}" font-family="Inter, system-ui, sans-serif" fill="\${textColor}" text-anchor="middle" font-weight="\${node.level === 0 ? '600' : '400'}" style="cursor: \${node.level === 1 && hasChildren ? 'pointer' : 'default'}">\${textLine}\</text>\`;
                });
                svg += collapseIndicator;
                node.children.forEach(drawNodes);
            };
            drawConnections(root);
            drawNodes(root);
            svg += '</svg>';
            return svg;
        }

        function renderMindmap() {
            const svgContainer = document.getElementById('svgContainer');
            svgContainer.innerHTML = '<div>Rendere Mindmap...</div>';
            try {
                const root = buildTreeFromDataForSVG();
                const svg = generateSVG(root);
                svgContainer.innerHTML = svg;
                const svgElement = svgContainer.querySelector('svg');
                svgElement.addEventListener('click', (e) => {
                    const target = e.target.closest('[data-node-id]');
                    if (target) {
                        const nodeId = parseInt(target.getAttribute('data-node-id'));
                        const node = mindmapData.find(n => n.id === nodeId);
                        if (node && node.level === 1 && mindmapData.some(n => n.parent === nodeId)) {
                            toggleCollapse(nodeId);
                        }
                    }
                });
            } catch (error) {
                svgContainer.innerHTML = \`<div style="background: #f1f3f4; padding: 20px; border-radius: 12px; border-left: 4px solid #dc2626;">
                    <h4 style="margin: 0 0 10px 0; color: #dc2626;">⚠️ Vorschau nicht verfügbar</h4>
                    <p style="color: #6b7280; margin: 0 0 15px 0; font-size: 14px;">Rendering-Fehler: \${error.message}</p>
                </div>\`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            renderMindmap();
        });
    </scr` + `ipt>
</body>
</html>
            `;

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'mindmap.html';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
            showSuccessModal('Mindmap wurde als HTML exportiert!');
        };

        // Copy Mermaid Code
        const copyMermaidCode = () => {
            const mermaidCode = generateMermaidCode().split('|').map(line => {
                const match = line.match(/^(~*)[^~]*/);
                return match ? '  '.repeat(match[1]?.length || 0) + match[0].replace(/^~*/, '') : line;
            }).join('\n');
            const textarea = document.createElement('textarea');
            textarea.value = mermaidCode;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showSuccessModal('Mermaid-Code wurde in die Zwischenablage kopiert!');
            } catch (err) {
                showErrorModal('Fehler beim Kopieren des Codes in die Zwischenablage.');
            }
            document.body.removeChild(textarea);
        };

        // Node validation
        const validateNodeText = (text, inputElement) => {
            if (!text.trim()) {
                showErrorModal('Die Eingabe darf nicht leer sein.');
                inputElement?.focus();
                return false;
            }
            if (text.length > MAX_TEXT_LENGTH) {
                showErrorModal(`Die Eingabe darf maximal ${MAX_TEXT_LENGTH} Zeichen lang sein.`);
                inputElement?.focus();
                return false;
            }
            if (/<[a-zA-Z0-9\s="/]*(>|\/>|on[a-zA-Z]+=["'])|[|~<>]/i.test(text)) {
                showErrorModal('Die Eingabe darf keinen HTML-Code, Skripte, "|", "~", "<" oder ">" enthalten.');
                inputElement?.focus();
                return false;
            }
            return true;
        };

        // Real-time input validation for SVG overlay
        const validateInputLength = (inputElement, nodeId) => {
            let text = inputElement.value;
            if (text.length > MAX_TEXT_LENGTH) {
                showErrorModal(`Die Eingabe darf maximal ${MAX_TEXT_LENGTH} Zeichen lang sein.`);
                inputElement.value = text.slice(0, MAX_TEXT_LENGTH);
                inputElement.focus();
            }
            if (/<[a-zA-Z0-9\s="/]*(>|\/>|on[a-zA-Z]+=["'])|[|~<>]/i.test(text)) {
                showErrorModal('Die Eingabe darf keinen HTML-Code, Skripte, "|", "~", "<" oder ">" enthalten.');
                inputElement.value = text.replace(/[<|~>]/g, '');
                inputElement.focus();
            }
        };

        // Initializes mind map data from Mermaid code
        function initializeFromMermaidCode() {
            if (!mermaidInput) {
                console.error('Element with ID "##id##" not found in the DOM.');
                showErrorModal('Interner Fehler: Das Eingabefeld für den Mermaid-Code wurde nicht gefunden.');
                mindmapData = [];
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block';
                return;
            }

            const codeInput = mermaidInput.value;
            const lines = codeInput.split('|').map(line => line.trimEnd()).filter(line => line.trim().length > 0);

            mindmapData = [];
            let levelMap = {};
            let branchIndexCounter = 0;

            if (!codeInput.trim() || lines.length === 0 || (lines.length === 1 && lines[0].trim() === 'mindmap')) {
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                mermaidInput.value = 'mindmap|root(Hauptknoten)';
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block';
                return;
            }

            if (!lines[0] || lines[0].trim() !== 'mindmap') {
                lines.unshift('mindmap');
            }

            lines.forEach((line, index) => {
                if (line.trim() === 'mindmap') return;

                const match = line.match(/^(~*)[^~]*/);
                if (!match) return;
                const level = match[1] ? match[1].length : 0;
                const textWithIndent = match[0];

                if (level > MAX_LEVEL) return;

                let parentId = null;
                if (level > 0) {
                    for (let i = level - 1; i >= 0; i--) {
                        if (levelMap[i] !== undefined) {
                            parentId = levelMap[i];
                            break;
                        }
                    }
                }

                if (parentId !== null) {
                    const childrenCount = mindmapData.filter(node => node.parent === parentId).length;
                    if (childrenCount >= MAX_CHILDREN_PER_NODE) return;
                }

                let text = textWithIndent.replace(/^~*/, '').trim();
                if (text.startsWith('root(') && text.endsWith(')')) {
                    text = text.slice(5, -1);
                }

                if (!validateNodeText(text)) return;

                const siblings = mindmapData.filter(n => n.parent === parentId);
                const order = siblings.length;

                const branchIndex = level === 0 ? 0 :
                    level === 1 ? branchIndexCounter++ :
                        mindmapData.find(n => n.id === parentId)?.branchIndex || 0;

                const newNode = {
                    id: nodeCounter++,
                    text: text,
                    level: level,
                    parent: parentId,
                    order: order,
                    branchIndex: branchIndex
                };

                mindmapData.push(newNode);
                levelMap[level] = newNode.id;

                Object.keys(levelMap).forEach(key => {
                    if (parseInt(key) > level) {
                        delete levelMap[key];
                    }
                });
            });

            if (mindmapData.length === 0) {
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                mermaidInput.value = 'mindmap|root(Hauptknoten)';
                if (welcomeMessage) welcomeMessage.style.display = 'block';
            } else if (welcomeMessage && !mindmapData.some(node => node.parent !== null)) {
                welcomeMessage.style.display = 'block';
            } else if (welcomeMessage) {
                welcomeMessage.style.display = 'none';
            }

            renderEditor();
        }

        // Collapse/expand function for Level 1 nodes
        const toggleCollapse = (nodeId) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.level !== 1) return;
            node.isCollapsed = !node.isCollapsed;
            renderEditor();
            renderMindmap();
        };

        // Checks whether a node is visible based on the isCollapsed state
        const isNodeVisible = (node) => {
            if (node.level === 0) return true;
            const parent = mindmapData.find(n => n.id === node.parent);
            if (!parent) return false;
            if (parent.level === 1 && parent.isCollapsed) return false;
            return isNodeVisible(parent);
        };

        // Node and editor rendering
        const getSortedNodes = () => {
            const nodes = [];
            const rootNodes = mindmapData.filter(node => node.level === 0).sort((a, b) => a.order - b.order);
            const addNodeAndChildren = node => {
                if (!isNodeVisible(node)) return;
                nodes.push(node);
                if (node.level === 1 && node.isCollapsed) return;
                mindmapData.filter(child => child.parent === node.id)
                    .sort((a, b) => (a.order || 0) - (b.order || 0))
                    .forEach(addNodeAndChildren);
            };
            rootNodes.forEach(addNodeAndChildren);
            return nodes;
        };

        const renderEditor = () => {
            if (!editor) return;
            editor.innerHTML = '';
            const sortedNodes = getSortedNodes();

            sortedNodes.forEach((node, index) => {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'node';
                nodeDiv.dataset.nodeId = node.id;
                nodeDiv.dataset.index = index;
                nodeDiv.dataset.level = node.level;
                nodeDiv.draggable = false;

                const parent = node.level > 0 ? mindmapData.find(n => n.id === node.parent) : null;
                node.branchIndex = node.level === 0 ? 0 :
                    node.level === 1 ? mindmapData.filter(n => n.parent === node.parent).sort((a, b) => (a.order || 0) - (b.order || 0)).indexOf(node) :
                        parent ? parent.branchIndex : 0;

                const collapseIcon = node.level === 1 ? `<span class="collapse-icon" onclick="toggleCollapse(${node.id})" title="${node.isCollapsed ? 'Ast ausklappen' : 'Ast einklappen'}">${node.isCollapsed ? '<i class="fa-solid fa-chevron-right"></i>' : '<i class="fa-solid fa-chevron-down"></i>'}</span>` : '';
                const addButton = node.level < MAX_LEVEL ? `` : '';
                const indent = node.level > 1 ? `<span class="indent">${'　'.repeat(node.level * 2)}</span>` : '';

                const colorElement = document.getElementById('color-##id##');
                let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';
                const colorScheme = BRANCH_COLORS_SCHEMES[selectedScheme] || BRANCH_COLORS_SCHEMES['Standard'];
                const inputBackgroundColor = node.level === 0 ? colorScheme.level0 :
                    node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                        node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                            '#ffffff';
                const textColor = getContrastTextColor(inputBackgroundColor);

                nodeDiv.innerHTML = `
                    ${indent}
                    ${collapseIcon}
                    ${addButton}
                    <input type="text" class="node-input" value="${node.text}" 
                           style="background-color: ${inputBackgroundColor}; color: ${textColor};"
                           oninput="validateInputLength(this, ${node.id})"
                           onchange="updateNodeText(${node.id}, this.value, this)"
                           placeholder="Knotenbeschriftung eingeben" 
                           draggable="false" 
                           data-node-id="${node.id}">
                `;

                const inputElement = nodeDiv.querySelector('.node-input');
                let isDragging = false;

                inputElement.addEventListener('mousedown', e => {
                    e.stopPropagation();
                    isDragging = false;
                    const input = e.target;
                    const rect = input.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const ctx = document.createElement('canvas').getContext('2d');
                    ctx.font = window.getComputedStyle(input).fontSize + ' ' + window.getComputedStyle(input).fontFamily;
                    const text = input.value;
                    let bestPosition = 0;
                    for (let i = 0; i <= text.length; i++) {
                        if (ctx.measureText(text.substring(0, i)).width + 10 >= clickX) {
                            bestPosition = i;
                            break;
                        }
                        bestPosition = i;
                    }
                    setTimeout(() => !isDragging && input.setSelectionRange(bestPosition, bestPosition), 0);
                });

                inputElement.addEventListener('click', e => {
                    e.stopPropagation();
                    if (isDragging) return e.preventDefault();
                    const input = e.target;
                    setTimeout(() => {
                        const rect = input.getBoundingClientRect();
                        if ((e.clientX - rect.left) > (rect.width - 20) * 0.9) {
                            input.setSelectionRange(input.value.length, input.value.length);
                        }
                    }, 10);
                });

                inputElement.addEventListener('keydown', e => (e.key === 'Enter' || e.keyCode === 13) && e.preventDefault() && e.target.blur());

                editor.appendChild(nodeDiv);
            });
        };

        // Help functions for node structure
        const getMaxDepth = nodeId => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node) return 0;
            const children = mindmapData.filter(n => n.parent === nodeId);
            return children.length ? Math.max(...children.map(child => 1 + getMaxDepth(child.id))) : 0;
        };

        const isDescendant = (ancestorId, nodeId) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.parent === null) return false;
            return node.parent === ancestorId || isDescendant(ancestorId, node.parent);
        };

        const updateChildrenLevels = (nodeId, newLevel) => {
            mindmapData.filter(n => n.parent === nodeId).forEach(child => {
                child.level = newLevel + 1;
                child.branchIndex = mindmapData.find(n => n.id === nodeId).branchIndex;
                child.isCollapsed = child.level === 1 ? false : undefined;
                updateChildrenLevels(child.id, child.level);
            });
        };

        const normalizeOrders = () => {
            const groups = {};
            mindmapData.forEach(node => {
                const key = node.parent === null ? 'root' : node.parent;
                groups[key] = groups[key] || [];
                groups[key].push(node);
            });
            Object.values(groups).forEach(group => {
                group.sort((a, b) => (a.order || 0) - (b.order || 0) || a.id - b.id)
                    .forEach((node, index) => node.order = index + 1000);
            });
        };

        // Mermaid and SVG generation
        const generateMermaidCode = () => {
            if (!mindmapData.length) return 'mindmap|root(Hauptknoten)';
            const rootNode = mindmapData.find(node => node.level === 0);
            if (!rootNode) return 'mindmap|root(Hauptknoten)';
            const addNodeToMermaid = (node, level = 0) => {
                const indent = '~'.repeat(level);
                const text = node.text.replace(/[]/g, '');
                let nodeCode = node.level === 0 ? `${indent}root(${text})` : `${indent}${text}`;
                const children = mindmapData.filter(child => child.parent === node.id).sort((a, b) => (a.order || 0) - (b.order || 0));
                return nodeCode + children.map(child => '|' + addNodeToMermaid(child, level + 1)).join('');
            };
            return 'mindmap|' + addNodeToMermaid(rootNode);
        };

        const buildTreeFromData = () => {
            const nodesMap = new Map(mindmapData.map(node => [node.id, { ...node, children: [] }]));
            let root = null;
            nodesMap.forEach(node => {
                if (node.level === 0) root = node;
                if (node.parent !== null) {
                    const parent = nodesMap.get(node.parent);
                    if (parent) parent.children.push(node);
                }
            });
            const sortChildren = node => {
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach(sortChildren);
            };
            if (root) sortChildren(root);
            return root;
        };

        const assignBranchColors = node => {
            const colorElement = document.getElementById('color-##id##');
            let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';
            const colorScheme = BRANCH_COLORS_SCHEMES[selectedScheme] || BRANCH_COLORS_SCHEMES['Standard'];
            node.color = node.level === 0 ? colorScheme.level0 :
                node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                    node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                        '#ffffff';
            node.textColor = getContrastTextColor(node.color);
            node.borderColor = node.level === 0 ? colorScheme.level0 : node.color;
            node.children.forEach(assignBranchColors);
        };

        const countNodes = node => 1 + node.children.reduce((sum, child) => sum + countNodes(child), 0);

        const calculateSubtreeSize = (node) => {
            const fontSize = Math.max(12, 18 - node.level);
            const maxWidth = 200;
            const words = node.text.split(' ').flatMap(word => {
                if (measureTextWidth(word, fontSize) > maxWidth) {
                    return splitLongWord(word, maxWidth, fontSize);
                }
                return word;
            });
            let line = '';
            const lines = [];
            words.forEach(word => {
                const testLine = line + word + ' ';
                if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = testLine;
                }
            });
            if (line.length > 0) lines.push(line.trim());
            const lineHeight = fontSize * 1.2;
            node.height = lines.length * lineHeight + 20;
            node.width = Math.max(100, maxWidth + 20);
            if (!node.children.length) {
                node.subtreeWidth = node.width;
                node.subtreeHeight = node.height;
                return;
            }
            node.children.forEach(calculateSubtreeSize);
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            node.subtreeHeight = node.children.reduce((sum, child) => sum + child.subtreeHeight, 0) + Math.max(0, node.children.length - 1) * spacing;
            node.subtreeWidth = node.width + 100 + Math.max(...node.children.map(c => c.subtreeWidth));
        };

        const positionNode = (node, x, y, direction) => {
            if (typeof node.x === 'undefined') {
                node.x = direction === 'left' ? x - node.width : x;
            }
            node.y = y + (node.subtreeHeight - node.height) / 2;
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            let currentY = y;
            node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
            node.children.forEach(child => {
                const childDirection = child.direction || direction;
                const offset = 100;
                const childX = childDirection === 'right' ? node.x + node.width + offset : node.x - offset;
                positionNode(child, childX, currentY, childDirection);
                currentY += child.subtreeHeight + spacing;
            });
        };

        const calculateLayout = (node, level = 0) => {
            if (level === 0) {
                calculateSubtreeSize(node);
                let rightChildren = [];
                let leftChildren = [];
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach((child, index) => {
                    child.direction = index % 2 === 0 ? 'right' : 'left';
                    if (child.direction === 'right') rightChildren.push(child);
                    else leftChildren.push(child);
                });
                const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
                let rightTotalHeight = rightChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, rightChildren.length - 1) * spacing;
                let leftTotalHeight = leftChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, leftChildren.length - 1) * spacing;
                let maxTotalHeight = Math.max(leftTotalHeight, rightTotalHeight, node.height);
                node.x = Math.max(leftTotalHeight, rightTotalHeight) + 100;
                node.y = maxTotalHeight / 2 - node.height / 2;
                let rightY = node.y + node.height / 2 - rightTotalHeight / 2;
                rightChildren.forEach(child => {
                    positionNode(child, node.x + node.width + 100, rightY, 'right');
                    rightY += child.subtreeHeight + spacing;
                });
                let leftY = node.y + node.height / 2 - leftTotalHeight / 2;
                leftChildren.forEach(child => {
                    const rightEdgeX = node.x - 100;
                    positionNode(child, rightEdgeX, leftY, 'left');
                    leftY += child.subtreeHeight + spacing;
                });
            }
        };

        const getConnectionPoint = (fromNode, toNode) => {
            const fromCenterX = fromNode.x + fromNode.width / 2;
            const fromCenterY = fromNode.y + fromNode.height / 2;
            const toCenterX = toNode.x + toNode.width / 2;
            const toCenterY = toNode.y + toNode.height / 2;
            const dx = toCenterX - fromCenterX;
            const dy = toCenterY - fromCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            return {
                fromX: fromCenterX + normalizedDx * (fromNode.width / 2),
                fromY: fromCenterY + normalizedDy * (fromNode.height / 2),
                toX: toCenterX - normalizedDx * (toNode.width / 2),
                toY: toCenterY - normalizedDy * (toNode.height / 2)
            };
        };

        const buildTreeFromDataForSVG = () => {
            const nodesMap = new Map(mindmapData.map(node => [node.id, { ...node, children: [] }]));
            let root = null;
            nodesMap.forEach(node => {
                if (node.level === 0) root = node;
                if (node.parent !== null) {
                    const parent = nodesMap.get(node.parent);
                    if (parent && (parent.level !== 1 || !parent.isCollapsed)) {
                        parent.children.push(node);
                    }
                }
            });
            const sortChildren = node => {
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach(sortChildren);
            };
            if (root) sortChildren(root);
            return root;
        };

        const generateSVG = root => {
            if (!root) return '';
            const padding = 100;
            assignBranchColors(root);
            calculateLayout(root);
            const { minX, minY, maxX, maxY } = getBounds(root);
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;
            let svg = `<svg width="${width}" height="${height}" viewBox="${minX - padding} ${minY - padding} ${width} ${height}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">`;
            const drawConnections = node => {
                node.children.forEach(child => {
                    const { fromX, fromY, toX, toY } = getConnectionPoint(node, child);
                    svg += `<line x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}" stroke="${BRANCH_COLORS[child.branchIndex % BRANCH_COLORS.length] || '#667eea'}" stroke-width="2" stroke-linecap="round"/>`;
                    drawConnections(child);
                });
            };
            const drawNodes = node => {
                const colorElement = document.getElementById('color-##id##');
                let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';
                const colorScheme = BRANCH_COLORS_SCHEMES[selectedScheme] || BRANCH_COLORS_SCHEMES['Standard'];
                const { fillColor, fillOpacity, strokeColor, strokeWidth, strokeDasharray } = node.level === 0
                    ? { fillColor: colorScheme.level0, strokeColor: colorScheme.level0, strokeWidth: 2, strokeDasharray: 'none' }
                    : node.level === 1
                        ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: 'none' }
                        : node.level === 2
                            ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], fillOpacity: '0.6', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' }
                            : { fillColor: '#ffffff', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' };
                const textColor = getContrastTextColor(fillColor);
                const originalNode = mindmapData.find(n => n.id === node.id);
                const hasChildren = mindmapData.some(n => n.parent === node.id);
                let collapseIndicator = '';
                if (node.level === 1 && hasChildren) {
                    const isCollapsed = originalNode && originalNode.isCollapsed;
                    const indicatorX = node.x + node.width - 15;
                    const indicatorY = node.y + 10;
                    collapseIndicator = `<text x="${indicatorX}" y="${indicatorY}" font-size="12" font-family="Arial, sans-serif" fill="${textColor}" text-anchor="middle">${isCollapsed ? '+' : '-'}</text>`;
                }
                svg += `<rect data-node-id="${node.id}" class="node-rect" x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="8" fill="${fillColor}" fill-opacity="${fillOpacity || '1'}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${strokeDasharray}" style="cursor: ${node.level === 1 && hasChildren ? 'pointer' : 'default'}"/>`;
                const words = node.text.split(' ').flatMap(word => {
                    const fontSize = Math.max(12, 18 - node.level);
                    if (measureTextWidth(word, fontSize) > 200) {
                        return splitLongWord(word, 200, fontSize);
                    }
                    return word;
                });
                let line = '';
                const lines = [];
                const maxWidth = 200;
                const fontSize = Math.max(12, 18 - node.level);
                words.forEach(word => {
                    const testLine = line + word + ' ';
                    if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                        lines.push(line.trim());
                        line = word + ' ';
                    } else {
                        line = testLine;
                    }
                });
                if (line.length > 0) lines.push(line.trim());
                const lineHeight = fontSize * 1.2;
                const totalTextHeight = lines.length * lineHeight;
                const startY = node.y + (node.height - totalTextHeight) / 2 + lineHeight * 0.7;
                lines.forEach((textLine, index) => {
                    svg += `<text data-node-id="${node.id}" class="node-text" x="${node.x + node.width / 2}" y="${startY + index * lineHeight}" font-size="${fontSize}" font-family="Inter, system-ui, sans-serif" fill="${textColor}" text-anchor="middle" font-weight="${node.level === 0 ? '600' : '400'}" style="cursor: ${node.level === 1 && hasChildren ? 'pointer' : 'default'}">${textLine}</text>`;
                });
                svg += collapseIndicator;
                node.children.forEach(drawNodes);
            };
            drawConnections(root);
            drawNodes(root);
            svg += '</svg>';
            return svg;
        };

        const getBounds = root => {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const updateBounds = node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
                node.children.forEach(updateBounds);
            };
            updateBounds(root);
            return { minX, minY, maxX, maxY };
        };

        const renderMindmap = () => {
            if (!mermaidInput) return;
            mermaidInput.value = generateMermaidCode();
            if (!previewContainer) return;
            previewContainer.innerHTML = '<div class="loading">Rendere Mindmap...</div>';
            try {
                const root = buildTreeFromDataForSVG();
                const svg = generateSVG(root);
                previewContainer.innerHTML = `<div id="mermaid-container-${Date.now()}" class="mermaid-container">${svg}</div>`;
                const existingOverlay = document.querySelector('.node-action-overlay, .input-overlay');
                if (existingOverlay) existingOverlay.remove();
                const svgContainer = previewContainer.querySelector('svg');
                if (svgContainer) {
                    svgContainer.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const existingOverlay = document.querySelector('.node-action-overlay, .input-overlay');
                        if (existingOverlay) existingOverlay.remove();
                        const target = e.target.closest('[data-node-id]');
                        if (target) {
                            const nodeId = parseInt(target.getAttribute('data-node-id'));
                            const node = mindmapData.find(n => n.id === nodeId);
                            if (!node) {
                                showErrorModal('Knoten nicht gefunden.');
                                return;
                            }
                            if (node.level === 1 && mindmapData.some(n => n.parent === nodeId)) {
                                toggleCollapse(nodeId);
                                return;
                            }
                            // Additional click handling for node actions can be added here
                        }
                    });
                }
                if (welcomeMessage && !hasInteractedWithRoot && !mindmapData.some(node => node.parent !== null)) {
                    welcomeMessage.style.display = 'block';
                } else if (welcomeMessage) {
                    welcomeMessage.style.display = 'none';
                }
            } catch (error) {
                const mermaidCode = mermaidInput.value.split('|').map(line => {
                    const match = line.match(/^(~*)[^~]*/);
                    return match ? ' '.repeat(match[1]?.length || 0) + match[0].replace(/^~*/, '') : line;
                }).join('\n');
                previewContainer.innerHTML = `
                    <div style="background: #f1f3f4; padding: 20px; border-radius: 12px; border-left: 4px solid #dc2626;">
                        <h4 style="margin: 0 0 10px 0; color: #dc2626;">⚠️ Vorschau nicht verfügbar</h4>
                        <p style="color: #6b7280; margin: 0 0 15px 0; font-size: 14px;">Rendering-Fehler: ${error.message}</p>
                        <h5 style="margin: 15px 0 10px 0; color: #1f2937;">📋 Generierter Code:</h5>
                        <pre style="background: white; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4; overflow-x: auto; margin: 0; border: 1px solid #e5e7eb;">${mermaidCode}</pre>
                    </div>
                `;
                if (welcomeMessage) welcomeMessage.style.display = 'none';
            }
        };

        function toggleFullscreen() {
            const fsContainer = document.getElementById("fullscreen_mindmap");
            const mermaid = document.getElementById("svgZoomContainer");
            const mindmap = document.getElementById("mindmapEditor");

            const isFullscreen = document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement;

            if (!isFullscreen) {
                // Vollbild starten
                if (fsContainer.requestFullscreen) fsContainer.requestFullscreen();
                else if (fsContainer.webkitRequestFullscreen) fsContainer.webkitRequestFullscreen();
                else if (fsContainer.msRequestFullscreen) fsContainer.msRequestFullscreen();

                // Child-Elemente anpassen
                mermaid?.classList.add("fullscreen-mermaid");
                editor?.classList.add("fullscreenMindmapEditor");
                mindmap?.classList.add("fullscreenMindmapEditor");
            } else {
                // Vollbild beenden
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();

                // Optional: Fullscreen-Klassen können hier bleiben,
                // werden beim Reload sowieso entfernt
            }
        }

        // Event Listener: ESC oder anderes Beenden des Vollbildes
        document.addEventListener("fullscreenchange", () => {
            const isFullscreen = document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement;

            if (!isFullscreen) {
                // **Seite neu laden**, um Dropdown-Probleme zu vermeiden
                location.reload();
            }
        });



    </script>
</div>