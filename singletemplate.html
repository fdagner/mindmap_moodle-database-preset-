<div class="conceptmap">
<h3>[[thema]]</h3>
<div class="inner">
    <div id="toolbar" class="container-fluid bg-dark text-white p-3 d-flex flex-wrap align-items-center gap-2 justify-content-end">
     <div class="config-section" style="display: none;">
             <label for="json##id##">Konfiguration (JSON):</label>
<input class="basefieldinput form-control d-inline mod-data-input" type="text" name="json##id##" id="json##id##" value=''>
        </div>
      <button type="button" id="exportSVG" class="btn btn-secondary btn-sm"><i class="fa-solid fa-file-export"></i> SVG</button>##actionsmenu##
</div>

    <div id="import-area" style="display: none;">[[code]]</div>
    
    
    <div id="canvas" style="touch-action: auto;">
      <svg id="svg"></svg>
    </div>

   </div>
  </div>
 
 

 
  <script>
    const canvas = document.querySelector('.conceptmap #canvas');
    const svg = document.querySelector('.conceptmap #svg');
    const jsonInput = document.querySelector('.conceptmap #json##id##');
    
    let nodes = [];
    let connections = [];
    let connectStart = null;
    let draggedNode = null;
    let draggedControl = null;
    let potentialDraggedControl = null;
    let dragStartPos = { x: 0, y: 0 };
    let hasMoved = false;
    let selectedNode = null;
    let selectedConnection = null;
    let nodeIdCounter = 1;
    let connectionIdCounter = 1;

    // SVG Pfeilspitze definieren
    svg.innerHTML = `
      <defs>
        <marker id="arrowhead" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
          <polygon points="0 0, 8 4, 0 8" fill="#2c3e50" />
        </marker>
      </defs>
    `;

    // Hole das Quell-div und das Ziel-input
    const sourceDiv = document.getElementById('import-area');
    const targetInput = document.getElementById('json##id##');

    // Entferne HTML-Tags und hole den reinen Text
    const cleanText = sourceDiv.innerText;

    // Setze den bereinigten Text als value des input-Elements
    targetInput.value = cleanText;

    // Initialisierung: JSON aus Input laden
    window.addEventListener('load', () => {
      if (jsonInput.value.trim()) {
        loadFromJSON(jsonInput.value);
      }
    });

    // Funktion zum Berechnen des Randpunkts
    function getBorderPoint(lineStartX, lineStartY, lineEndX, lineEndY, rect, canvasRect) {
      const dx = lineEndX - lineStartX;
      const dy = lineEndY - lineStartY;
      const left = rect.left - canvasRect.left;
      const top = rect.top - canvasRect.top;
      const right = left + rect.width;
      const bottom = top + rect.height;
      const intersections = [];

      if (dx !== 0) {
        const t = (left - lineStartX) / dx;
        if (t > 0 && t <= 1) {
          const y = lineStartY + t * dy;
          if (y >= top && y <= bottom) intersections.push({x: left, y, t});
        }
      }

      if (dx !== 0) {
        const t = (right - lineStartX) / dx;
        if (t > 0 && t <= 1) {
          const y = lineStartY + t * dy;
          if (y >= top && y <= bottom) intersections.push({x: right, y, t});
        }
      }

      if (dy !== 0) {
        const t = (top - lineStartY) / dy;
        if (t > 0 && t <= 1) {
          const x = lineStartX + t * dx;
          if (x >= left && x <= right) intersections.push({x, y: top, t});
        }
      }

      if (dy !== 0) {
        const t = (bottom - lineStartY) / dy;
        if (t > 0 && t <= 1) {
          const x = lineStartX + t * dx;
          if (x >= left && x <= right) intersections.push({x, y: bottom, t});
        }
      }

      if (intersections.length > 0) {
        intersections.sort((a, b) => a.t - b.t);
        return intersections[0];
      }
      return {x: lineEndX, y: lineEndY};
    }

    let mode = 'default';

    // Node erstellen
    function createNode(x, y, text = 'Neues Konzept', id = null, backgroundColor = 'white') {
      const node = document.createElement('div');
      node.className = 'node';
      node.style.left = x + 'px';
      node.style.top = y + 'px';
      node.style.backgroundColor = backgroundColor;
      node.style.zIndex = '10';
      node.style.maxWidth = '200px'; 
      node.style.wordWrap = 'break-word'; // Wortumbruch aktivieren
      node.style.overflowWrap = 'break-word'; // Zusätzlicher Fallback für Wortumbruch
      
      const nodeText = document.createElement('div');
      nodeText.className = 'node-text';
      nodeText.textContent = text;
      nodeText.style.width = '100%'; // Vollbreite nutzen
      nodeText.style.wordWrap = 'break-word'; // Wortumbruch im Text-Element
      nodeText.style.overflowWrap = 'break-word';
      nodeText.style.whiteSpace = 'normal'; // Mehrzeiligen Text erlauben
      nodeText.style.lineHeight = '1.2'; // Zeilenhöhe für bessere Lesbarkeit
      nodeText.style.padding = '8px'; // Optional: Padding für bessere Optik
      node.appendChild(nodeText);

      // "Verbinden"-Button außerhalb des Nodes
      const connectBtn = document.createElement('button');
      connectBtn.className = 'node-connect-btn';
      connectBtn.textContent = '+';
      connectBtn.title = 'Verbindung erstellen';
      canvas.appendChild(connectBtn);

      const nodeData = {
        id: id || nodeIdCounter++,
        element: node,
        connectBtn: connectBtn,
        x: x,
        y: y,
        backgroundColor: backgroundColor
      };
      
      nodes.push(nodeData);
      canvas.appendChild(node);


    }

    

    function createConnection(from, to, label = '', controlX, controlY, id = null) {
      const conn = {
        id: id || connectionIdCounter++,
        from: from.id,
        to: to.id,
        label: label,
        labelElement: null,
        controlX: controlX,
        controlY: controlY,
        isDragging: false
      };
      connections.push(conn);
      renderConnections();
      saveToJSON();
    }

    // Verbindungen zeichnen
 function renderConnections() {
  while (svg.children.length > 1) {
    svg.removeChild(svg.lastChild);
  }

  connections.forEach(conn => {
    const fromNode = nodes.find(n => n.id === conn.from);
    const toNode = nodes.find(n => n.id === conn.to);
    
    if (!fromNode || !toNode) return;

    const fromRect = fromNode.element.getBoundingClientRect();
    const toRect = toNode.element.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();

    const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
    const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
    const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
    const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

    let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect);
    if (!startPoint) startPoint = {x: x1, y: y1};
    let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect);
    if (!endPoint) endPoint = {x: x2, y: y2};

    const startX = startPoint.x;
    const startY = startPoint.y;
    const endX = endPoint.x;
    const endY = endPoint.y;
    const controlX = conn.controlX;
    const controlY = conn.controlY;

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`;
    path.setAttribute('d', d);
    path.setAttribute('class', 'connection');
    if (selectedConnection === conn) {
      path.classList.add('selected');
    }
    path.addEventListener('click', (e) => {
      e.stopPropagation();
      selectConnection(conn);
    });
    svg.appendChild(path);

    const t = 0.5;
    const labelX = (1 - t) ** 2 * startX + 2 * (1 - t) * t * controlX + t ** 2 * endX;
    const labelY = (1 - t) ** 2 * startY + 2 * (1 - t) * t * controlY + t ** 2 * endY;

    // Nur Label rendern, wenn es nicht leer ist
    if (conn.label && conn.label.trim() !== '') {
      if (!conn.labelElement) {
        const labelDiv = document.createElement('div');
        labelDiv.className = 'connection-label';
        labelDiv.textContent = conn.label;
        labelDiv.style.left = `${labelX - 50}px`;
        labelDiv.style.top = `${labelY - 10}px`;
        canvas.appendChild(labelDiv);
        conn.labelElement = labelDiv;
        attachLabelEvents(labelDiv, conn);
      } else {
        conn.labelElement.style.left = `${labelX - 50}px`;
        conn.labelElement.style.top = `${labelY - 10}px`;
        if (conn.labelElement.tagName === 'DIV') {
          conn.labelElement.textContent = conn.label;
        }
      }
    } else {
      // Entferne vorhandenes labelElement, falls es existiert
      if (conn.labelElement) {
        conn.labelElement.remove();
        conn.labelElement = null;
      }
    }
  });
}

    function selectConnection(conn) {
      selectedConnection = conn;
      if (selectedNode) {
        selectedNode.element.classList.remove('selected');
        selectedNode.connectBtn.style.display = 'none';
        selectedNode = null;
      }
      renderConnections();
    }

   // Hilfsfunktion für Textumbruch im SVG
function wrapSVGText(text, maxWidth, fontSize, lineHeight, ctx) {
  const words = text.split(' ');
  const lines = [];
  let currentLine = '';
  
  words.forEach(word => {
    const testLine = currentLine + (currentLine ? ' ' : '') + word;
    const metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth) {
      if (currentLine) lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  });
  if (currentLine) lines.push(currentLine);
  
  return lines;
}

// SVG Export Funktion
function exportToSVG() {
  if (nodes.length === 0 && connections.length === 0) {
    alert('Nichts zu exportieren.');
    return;
  }

  // Temporäres Canvas für genaue Textmessung erstellen
  const measureCanvas = document.createElement('canvas');
  const measureCtx = measureCanvas.getContext('2d');
  measureCtx.font = '14px Arial, sans-serif'; // Passe an die Font im SVG an

  const canvasRect = canvas.getBoundingClientRect();
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  // Bounding Box für Nodes berechnen
  nodes.forEach(node => {
    const rect = node.element.getBoundingClientRect();
    const x = rect.left - canvasRect.left;
    const y = rect.top - canvasRect.top;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + rect.width);
    maxY = Math.max(maxY, y + rect.height);
  });

  // Bounding Box für Connections und Labels berechnen
  connections.forEach(conn => {
    const fromNode = nodes.find(n => n.id === conn.from);
    const toNode = nodes.find(n => n.id === conn.to);
    
    if (!fromNode || !toNode) return;

    const fromRect = fromNode.element.getBoundingClientRect();
    const toRect = toNode.element.getBoundingClientRect();

    const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
    const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
    const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
    const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

    let startPoint = getBorderPoint(x1, y1, x2, y2, fromRect, canvasRect) || {x: x1, y: y1};
    let endPoint = getBorderPoint(x2, y2, x1, y1, toRect, canvasRect) || {x: x2, y: y2};

    const startX = startPoint.x;
    const startY = startPoint.y;
    const endX = endPoint.x;
    const endY = endPoint.y;
    const controlX = conn.controlX;
    const controlY = conn.controlY;

    minX = Math.min(minX, startX, controlX, endX);
    minY = Math.min(minY, startY, controlY, endY);
    maxX = Math.max(maxX, startX, controlX, endX);
    maxY = Math.max(maxY, startY, controlY, endY);

    if (conn.label) {
      const t = 0.5;
      const labelX = (1 - t) ** 2 * startX + 2 * (1 - t) * t * controlX + t ** 2 * endX;
      const labelY = (1 - t) ** 2 * startY + 2 * (1 - t) * t * controlY + t ** 2 * endY;
      minX = Math.min(minX, labelX - 50);
      minY = Math.min(minY, labelY - 10);
      maxX = Math.max(maxX, labelX + 50);
      maxY = Math.max(maxY, labelY + 10);
    }
  });

  // Padding hinzufügen
  const padding = 20;
  minX -= padding;
  minY -= padding;
  maxX += padding;
  maxY += padding;

  const width = maxX - minX;
  const height = maxY - minY;

  // SVG-Header
  let svgContent = `
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <marker id="arrowhead" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
          <polygon points="0 0, 8 4, 0 8" fill="#2c3e50" />
        </marker>
      </defs>
  `;

  // Nodes zeichnen (Koordinaten anpassen)
  nodes.forEach(node => {
    const rect = node.element.getBoundingClientRect();
    const x = (rect.left - canvasRect.left) - minX;
    const y = (rect.top - canvasRect.top) - minY;
    const nodeWidth = rect.width;
    const nodeHeight = rect.height;
    const text = node.element.querySelector('.node-text').textContent;
    const backgroundColor = node.backgroundColor || 'white';
    const borderColor = node === selectedNode ? '#e74c3c' : '#3498db';
    const shadow = node === selectedNode ? '0 0 0 3px rgba(231, 76, 60, 0.3)' : '0 2px 8px rgba(0,0,0,0.15)';

    // Text umbrechen mit genauer Messung
    const fontSize = 14;
    const lineHeight = fontSize * 1.2;
    const maxTextWidth = nodeWidth - 16; // Padding abziehen (8px pro Seite)
    const lines = wrapSVGText(text, maxTextWidth, fontSize, lineHeight, measureCtx);
    const textHeight = lines.length * lineHeight;
    const textY = y + (nodeHeight - textHeight) / 2 + lineHeight / 2; // Zentrieren

    svgContent += `
      <rect x="${x}" y="${y}" width="${nodeWidth}" height="${nodeHeight}"
            fill="${backgroundColor}" stroke="${borderColor}" stroke-width="3"
            rx="8" ry="8" style="filter: drop-shadow(${shadow});" />
      <text x="${x + nodeWidth / 2}" y="${textY}"
            font-family="Arial, sans-serif" font-size="${fontSize}"
            fill="#2c3e50" text-anchor="middle" dominant-baseline="middle">
    `;
    lines.forEach((line, index) => {
      if (index === 0) {
        svgContent += `<tspan x="${x + nodeWidth / 2}" dy="0">${line}</tspan>`;
      } else {
        svgContent += `<tspan x="${x + nodeWidth / 2}" dy="${lineHeight}">${line}</tspan>`;
      }
    });
    svgContent += `</text>`;
  });

  // Verbindungen zeichnen (Koordinaten anpassen)
  connections.forEach(conn => {
    const fromNode = nodes.find(n => n.id === conn.from);
    const toNode = nodes.find(n => n.id === conn.to);
    
    if (!fromNode || !toNode) return;

    const fromRect = fromNode.element.getBoundingClientRect();
    const toRect = toNode.element.getBoundingClientRect();

    const x1 = (fromRect.left + fromRect.width / 2 - canvasRect.left) - minX;
    const y1 = (fromRect.top + fromRect.height / 2 - canvasRect.top) - minY;
    const x2 = (toRect.left + toRect.width / 2 - canvasRect.left) - minX;
    const y2 = (toRect.top + toRect.height / 2 - canvasRect.top) - minY;

    let startPoint = getBorderPoint(x1 + minX, y1 + minY, x2 + minX, y2 + minY, fromRect, canvasRect);
    if (!startPoint) startPoint = {x: x1 + minX, y: y1 + minY};
    startPoint.x -= minX;
    startPoint.y -= minY;

    let endPoint = getBorderPoint(x2 + minX, y2 + minY, x1 + minX, y1 + minY, toRect, canvasRect);
    if (!endPoint) endPoint = {x: x2 + minX, y: y2 + minY};
    endPoint.x -= minX;
    endPoint.y -= minY;

    const startX = startPoint.x;
    const startY = startPoint.y;
    const endX = endPoint.x;
    const endY = endPoint.y;
    const controlX = conn.controlX - minX;
    const controlY = conn.controlY - minY;

    const strokeColor = conn === selectedConnection ? '#e74c3c' : '#95a5a6';

    svgContent += `
      <path d="M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}"
            stroke="${strokeColor}" stroke-width="3" fill="none"
            marker-end="url(#arrowhead)" stroke-linecap="round" />
    `;

    if (conn.label && conn.label.trim() !== '') {
      const t = 0.5;
      const labelX = (1 - t) ** 2 * startX + 2 * (1 - t) * t * controlX + t ** 2 * endX;
      const labelY = (1 - t) ** 2 * startY + 2 * (1 - t) * t * controlY + t ** 2 * endY;
      // Label mit Textumbruch rendern
      const labelFontSize = 12;
      const labelLineHeight = labelFontSize * 1.2;
      measureCtx.font = `${labelFontSize}px Arial, sans-serif`;
      const labelPadding = 4;
      const maxLabelTextWidth = 100 - 2 * labelPadding;
      const labelLines = wrapSVGText(conn.label, maxLabelTextWidth, labelFontSize, labelLineHeight, measureCtx);
      const labelTextHeight = labelLines.length * labelLineHeight;
      const labelRectHeight = labelTextHeight + 2 * labelPadding;
      const labelRectWidth = 100;
      const labelRectX = labelX - labelRectWidth / 2;
      const labelRectY = labelY - labelRectHeight / 2;
      const labelTextY = labelRectY + labelPadding + labelLineHeight / 2; // Baseline für erste Zeile

      svgContent += `
        <rect x="${labelRectX}" y="${labelRectY}" width="${labelRectWidth}" height="${labelRectHeight}"
              fill="white" stroke="#95a5a6" stroke-width="1" rx="3" ry="3" />
        <text x="${labelX}" y="${labelTextY}"
              font-family="Arial, sans-serif" font-size="${labelFontSize}"
              fill="#2c3e50" text-anchor="middle" dominant-baseline="central">
      `;
      labelLines.forEach((line, index) => {
        const dy = index * labelLineHeight;
        svgContent += `<tspan x="${labelX}" dy="${dy}">${line}</tspan>`;
      });
      svgContent += `</text>`;
    }
  });
  svgContent += `</svg>`;

  // SVG als Datei herunterladen
  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'concept_map.svg';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
 
    document.querySelector('.conceptmap #exportSVG').addEventListener('click', () => {
      exportToSVG();
    });


    function saveToJSON() {
      const data = {
        nodes: nodes.map(n => ({
          id: n.id,
          x: n.x,
          y: n.y,
          text: n.element.querySelector('.node-text').textContent,
          backgroundColor: n.backgroundColor
        })),
        connections: connections.map(c => ({
          id: c.id,
          from: c.from,
          to: c.to,
          label: c.label,
          controlX: c.controlX,
          controlY: c.controlY
        }))
      };
      jsonInput.value = JSON.stringify(data);
    }

    function loadFromJSON(jsonStr) {
      try {
        const data = JSON.parse(jsonStr);
        
        nodes.forEach(n => {
          n.element.remove();
          n.connectBtn.remove();
        });
        connections.forEach(c => {
          if (c.labelElement) c.labelElement.remove();
        });
        nodes = [];
        connections = [];
        
        if (data.nodes) {
          data.nodes.forEach(n => {
            createNode(n.x, n.y, n.text, n.id, n.backgroundColor);
            if (n.id >= nodeIdCounter) nodeIdCounter = n.id + 1;
          });
        }
        
        if (data.connections) {
          data.connections.forEach(c => {
            const from = nodes.find(n => n.id === c.from);
            const to = nodes.find(n => n.id === c.to);
            if (from && to) {
              createConnection(from, to, c.label, c.controlX, c.controlY, c.id);
              if (c.id >= connectionIdCounter) connectionIdCounter = c.id + 1;
            }
          });
        }
        
        renderConnections();
      } catch (e) {
        alert('Fehler beim Laden: Ungültiges JSON-Format');
      }
    }


    function attachLabelEvents(element, conn) {
      let lastTap = 0;

      const editLabel = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const input = document.createElement('input');
        input.type = 'text';
        input.value = conn.label;
        input.style.width = '100%';
        input.style.position = 'absolute';
        input.style.left = '0';
        input.style.top = '0';
        input.style.zIndex = '100';
        element.appendChild(input);
        input.focus();
        input.select();
        const saveInput = () => {
          const newLabel = input.value.trim();
          conn.label = newLabel;
          renderConnections();
          saveToJSON();
          input.remove();
        };
        input.addEventListener('blur', saveInput);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
          }
        });
      };
   

      element.addEventListener('click', (e) => {
        e.stopPropagation();
        const now = new Date().getTime();
        if (now - lastTap < 300) {
          editLabel(e);
        }
        lastTap = now;
      });

      element.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        editLabel(e);
      });
    }

  </script>