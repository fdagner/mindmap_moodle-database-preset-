<style>
    .node-action-overlay {
        display: none;
    }

    #color-##id## {
        background-color: #f8f9fa;
        border-color: #f8f9fa;
    }
</style>

<div class="main-content" id="fullscreen_mindmap">
    <h3>##actionsmenu##Mindmap von ##user##</h3>
    <div class="zoom-controls">
        <div class="mindmap">
            <div class="mindmap_buttons">
                <button type="button" class="btn btn-light toggle-editor-btn" onclick="toggleEditor()"
                    title="Listenmodus umschalten"><i class="fa-solid fa-list"></i></button>
                <button type="button" class="btn btn-light" onclick="zoomSvg(1.2)" title="Hineinzoomen"><i
                        class="fa-solid fa-magnifying-glass-plus"></i></button>
                <button type="button" class="btn btn-light" onclick="zoomSvg(1/1.2)" title="Herauszoomen"><i
                        class="fa-solid fa-magnifying-glass-minus"></i></button>
                <button type="button" class="btn btn-light" onclick="resetZoom()" title="Zoom zur√ºcksetzen"><i
                        class="fa-solid fa-arrows-to-circle"></i></button>
                <button type="button" class="btn btn-light" onclick="toggleFullscreen()" titel="Pr√§sentationsmodus"><i
                        class="fa-solid fa-person-chalkboard"></i></button>
                <button type="button" class="btn btn-light" onclick="exportAsSVG()" title="Als SVG exportieren"><i
                        class="fa-solid fa-file"></i></button>
                <button type="button" class="btn btn-light" onclick="copyMermaidCode()" title="Mermaid-Code kopieren"><i
                        class="fa-solid fa-code"></i></button>
            </div>
        </div>
        <p id="color-##id##" style="display: none">[[color_theme]]</p>
        <div class="editor-panel" style="display: none;">
            <div id="mindmapEditor" class="mindmap-tree"></div>
            <div class="export-area" style="display: none;">
                <strong>Mermaid Code:</strong>
                <input type="text" id="##id##" class="export-input"
                    placeholder="Use ~ for each indentation level and | to separate nodes" value="[[mermaid_text]]">
            </div>
        </div>
        <div class="preview-panel">
            <div id="mermaidPreview" class="loading">
                <div id="welcomeMessage">
                    Klicke auf den Hauptknoten, um zu beginnen üòÄ...
                </div>
                <div id="svgZoomContainer"></div>
            </div>
        </div>
    </div>

    <div id="deleteModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Knoten l√∂schen</h3>
            <p id="deleteModalMessage"></p>
            <div class="mindmap-modal-buttons" id="deleteModalButtons"></div>
        </div>
    </div>

    <div id="errorModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Fehler</h3>
            <p id="errorModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeErrorModal()">OK</button>
            </div>
        </div>
    </div>

    <div id="successModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Erfolg</h3>
            <p id="successModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeSuccessModal()">OK</button>
            </div>
        </div>
    </div>

    <div id="warningModal" class="mindmap-modal">
        <div class="mindmap-modal-content">
            <h3>Warnung</h3>
            <p id="warningModalMessage"></p>
            <div class="mindmap-modal-buttons">
                <button type="button" class="btn btn-primary" onclick="closeWarningModal()">OK</button>
            </div>
        </div>
    </div>

    <script>

        let BRANCH_COLORS = BRANCH_COLORS_SCHEMES['Standard'].colors;
        const editor = document.getElementById('mindmapEditor');
        const previewContainer = document.getElementById('svgZoomContainer');
        const mermaidInput = document.getElementById('##id##');
        const welcomeMessage = document.getElementById('welcomeMessage');


        // Function for setting the color scheme
        function setColorScheme() {
            const colorElement = document.getElementById('color-##id##');
            let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';

            if (BRANCH_COLORS_SCHEMES[selectedScheme]) {
                BRANCH_COLORS = [...BRANCH_COLORS_SCHEMES[selectedScheme].colors];
            } else {
                BRANCH_COLORS = [...BRANCH_COLORS_SCHEMES['Standard'].colors];
            }

            renderEditor();
            renderMindmap();
        }

        // Function to show/hide the editor
        const toggleEditor = () => {
            const editorPanel = document.querySelector('.editor-panel');
            const previewPanel = document.querySelector('.preview-panel');
            const toggleButton = document.querySelector('.toggle-editor-btn');
            const zoomButtons = document.querySelectorAll('.zoom-controls .btn.btn-light:not(.toggle-editor-btn)');

            if (editorPanel.style.display === 'none') {
                editorPanel.style.display = 'block';
                previewPanel.style.display = 'none';
                toggleButton.innerHTML = '<i class="fa-solid fa-lightbulb"></i>';
                zoomButtons.forEach(button => button.style.display = 'none');
                if (welcomeMessage) welcomeMessage.style.display = 'none'; // Hide message when switching to editor
            } else {
                editorPanel.style.display = 'none';
                previewPanel.style.display = 'block';
                toggleButton.innerHTML = '<i class="fa-solid fa-list"></i>';
                zoomButtons.forEach(button => button.style.display = 'inline-block');
                // Show message if no children and no interaction yet
                if (welcomeMessage && !hasInteractedWithRoot && !mindmapData.some(node => node.parent !== null)) {
                    welcomeMessage.style.display = 'block';
                }
            }
        };

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            if (!editor || !previewContainer || !mermaidInput || !welcomeMessage) {
                console.error('Required DOM elements are missing:', {
                    mindmapEditor: !!editor,
                    svgZoomContainer: !!previewContainer,
                    mermaidInput: !!mermaidInput,
                    welcomeMessage: !!welcomeMessage
                });
                showErrorModal('Interner Fehler: Erforderliche DOM-Elemente fehlen. Bitte √ºberpr√ºfen Sie die HTML-Struktur.');
                mindmapData = [];
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block';
                return;
            }
            initializeFromMermaidCode();
            setColorScheme();
            renderMindmap();
        });

        // Zoom
        const zoomSvg = (factor) => {
            if (!previewContainer) return;
            currentZoom *= factor;
            previewContainer.style.transformOrigin = '0 0';
            previewContainer.style.transform = `scale(${currentZoom})`;
            document.getElementById('mermaidPreview').style.overflow = 'auto';
        };

        const resetZoom = () => {
            if (!previewContainer) return;
            currentZoom = 1;
            previewContainer.style.transform = 'none';
            document.getElementById('mermaidPreview').style.overflow = 'auto';
        };


        // Export
        const exportAsSVG = () => {
            const svgElement = document.getElementById('mermaidPreview').querySelector('svg');
            if (!svgElement) return showErrorModal('Keine Mindmap verf√ºgbar. Bitte rendere die Mindmap zuerst.');
            const svgData = new XMLSerializer().serializeToString(svgElement.cloneNode(true));
            const svgBlob = new Blob(['<?xml version="1.0" standalone="no"?>\n' + svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(svgBlob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'mindmap.svg';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
            showSuccessModal('Mindmap wurde als SVG exportiert!');
        };

        const copyMermaidCode = () => {
            const mermaidCode = generateMermaidCode().split('|').map(line => {
                const match = line.match(/^(~*)[^~]*/);
                return match ? '  '.repeat(match[1]?.length || 0) + match[0].replace(/^~*/, '') : line;
            }).join('\n');
            const textarea = document.createElement('textarea');
            textarea.value = mermaidCode;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showSuccessModal('Mermaid-Code wurde in die Zwischenablage kopiert!');
            } catch (err) {
                showErrorModal('Fehler beim Kopieren des Codes in die Zwischenablage.');
            }
            document.body.removeChild(textarea);
        };

        // Node validation
        const validateNodeText = (text, inputElement) => {
            if (!text.trim()) {
                showErrorModal('Die Eingabe darf nicht leer sein.');
                inputElement?.focus();
                return false;
            }
            if (text.length > MAX_TEXT_LENGTH) {
                showErrorModal(`Die Eingabe darf maximal ${MAX_TEXT_LENGTH} Zeichen lang sein.`);
                inputElement?.focus();
                return false;
            }
            if (/<[a-zA-Z0-9\s="/]*(>|\/>|on[a-zA-Z]+=["'])|[|~<>]/i.test(text)) {
                showErrorModal('Die Eingabe darf keinen HTML-Code, Skripte, "|", "~", "<" oder ">" enthalten.');
                inputElement?.focus();
                return false;
            }
            return true;
        };

        // Real-time input validation for SVG overlay
        const validateInputLength = (inputElement, nodeId) => {
            let text = inputElement.value;
            if (text.length > MAX_TEXT_LENGTH) {
                showErrorModal(`Die Eingabe darf maximal ${MAX_TEXT_LENGTH} Zeichen lang sein.`);
                inputElement.value = text.slice(0, MAX_TEXT_LENGTH);
                inputElement.focus();
            }
            if (/<[a-zA-Z0-9\s="/]*(>|\/>|on[a-zA-Z]+=["'])|[|~<>]/i.test(text)) {
                showErrorModal('Die Eingabe darf keinen HTML-Code, Skripte, "|", "~", "<" oder ">" enthalten.');
                inputElement.value = text.replace(/[<|~>]/g, '');
                inputElement.focus();
            }
        };

        // Initializes mind map data from Mermaid code
        function initializeFromMermaidCode() {
            if (!mermaidInput) {
                console.error('Element with ID "##id##" not found in the DOM.');
                showErrorModal('Interner Fehler: Das Eingabefeld f√ºr den Mermaid-Code wurde nicht gefunden.');
                mindmapData = [];
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message for default case
                return;
            }

            const codeInput = mermaidInput.value;
            const lines = codeInput.split('|').map(line => line.trimEnd()).filter(line => line.trim().length > 0);

            mindmapData = [];
            let levelMap = {};
            let branchIndexCounter = 0;

            if (!codeInput.trim() || lines.length === 0 || (lines.length === 1 && lines[0].trim() === 'mindmap')) {
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                mermaidInput.value = 'mindmap|root(Hauptknoten)';
                renderEditor();
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message for empty mindmap
                return;
            }

            if (!lines[0] || lines[0].trim() !== 'mindmap') {
                lines.unshift('mindmap');
            }

            lines.forEach((line, index) => {
                if (line.trim() === 'mindmap') return;

                const match = line.match(/^(~*)[^~]*/);
                if (!match) return;
                const level = match[1] ? match[1].length : 0;
                const textWithIndent = match[0];

                if (level > MAX_LEVEL) return;

                let parentId = null;
                if (level > 0) {
                    for (let i = level - 1; i >= 0; i--) {
                        if (levelMap[i] !== undefined) {
                            parentId = levelMap[i];
                            break;
                        }
                    }
                }

                if (parentId !== null) {
                    const childrenCount = mindmapData.filter(node => node.parent === parentId).length;
                    if (childrenCount >= MAX_CHILDREN_PER_NODE) return;
                }

                let text = textWithIndent.replace(/^~*/, '').trim();
                if (text.startsWith('root(') && text.endsWith(')')) {
                    text = text.slice(5, -1);
                }

                if (!validateNodeText(text)) return;

                const siblings = mindmapData.filter(n => n.parent === parentId);
                const order = siblings.length;

                const branchIndex = level === 0 ? 0 :
                    level === 1 ? branchIndexCounter++ :
                        mindmapData.find(n => n.id === parentId)?.branchIndex || 0;

                const newNode = {
                    id: nodeCounter++,
                    text: text,
                    level: level,
                    parent: parentId,
                    order: order,
                    branchIndex: branchIndex
                };

                mindmapData.push(newNode);
                levelMap[level] = newNode.id;

                Object.keys(levelMap).forEach(key => {
                    if (parseInt(key) > level) {
                        delete levelMap[key];
                    }
                });
            });

            if (mindmapData.length === 0) {
                const defaultRootNode = {
                    id: nodeCounter++,
                    text: 'Hauptknoten',
                    level: 0,
                    parent: null,
                    order: 0,
                    branchIndex: 0
                };
                mindmapData.push(defaultRootNode);
                mermaidInput.value = 'mindmap|root(Hauptknoten)';
                if (welcomeMessage) welcomeMessage.style.display = 'block'; // Show message for empty mindmap
            } else if (welcomeMessage && !mindmapData.some(node => node.parent !== null)) {
                welcomeMessage.style.display = 'block'; // Show message if no child nodes
            } else if (welcomeMessage) {
                welcomeMessage.style.display = 'none'; // Hide message if there are child nodes
            }

            renderEditor();
        }

        // Collapse/expand function for Level 1 nodes - UPDATED to also render mindmap
        const toggleCollapse = (nodeId) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.level !== 1) return;
            node.isCollapsed = !node.isCollapsed;
            renderEditor();
            renderMindmap(); // Added this line to update SVG as well
        };

        // Checks whether a node is visible based on the isCollapsed state of its ancestors
        const isNodeVisible = (node) => {
            if (node.level === 0) return true;
            const parent = mindmapData.find(n => n.id === node.parent);
            if (!parent) return false;
            if (parent.level === 1 && parent.isCollapsed) return false;
            return isNodeVisible(parent);
        };

        // Node and editor rendering
        const getSortedNodes = () => {
            const nodes = [];
            const rootNodes = mindmapData.filter(node => node.level === 0).sort((a, b) => a.order - b.order);
            const addNodeAndChildren = node => {
                if (!isNodeVisible(node)) return;
                nodes.push(node);
                if (node.level === 1 && node.isCollapsed) return;
                mindmapData.filter(child => child.parent === node.id)
                    .sort((a, b) => (a.order || 0) - (b.order || 0))
                    .forEach(addNodeAndChildren);
            };
            rootNodes.forEach(addNodeAndChildren);
            return nodes;
        };

        const renderEditor = () => {
            if (!editor) return;
            editor.innerHTML = '';
            const sortedNodes = getSortedNodes();

            sortedNodes.forEach((node, index) => {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'node';
                nodeDiv.dataset.nodeId = node.id;
                nodeDiv.dataset.index = index;
                nodeDiv.dataset.level = node.level;
                nodeDiv.draggable = false;

                // Ensure that branchIndex is correct
                const parent = node.level > 0 ? mindmapData.find(n => n.id === node.parent) : null;
                node.branchIndex = node.level === 0 ? 0 :
                    node.level === 1 ? mindmapData.filter(n => n.parent === node.parent).sort((a, b) => (a.order || 0) - (b.order || 0)).indexOf(node) :
                        parent ? parent.branchIndex : 0;

                const collapseIcon = node.level === 1 ? `<span class="collapse-icon" onclick="toggleCollapse(${node.id})" title="${node.isCollapsed ? 'Ast ausklappen' : 'Ast einklappen'}">${node.isCollapsed ? '<i class="fa-solid fa-chevron-right"></i>' : '<i class="fa-solid fa-chevron-down"></i>'}</span>` : '';
                const addButton = node.level < MAX_LEVEL ? `` : '';
                const indent = node.level > 1 ? `<span class="indent">${'„ÄÄ'.repeat(node.level * 2)}</span>` : '';

                const colorElement = document.getElementById('color-##id##');
                let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';
                const colorScheme = BRANCH_COLORS_SCHEMES[selectedScheme] || BRANCH_COLORS_SCHEMES['Standard'];
                const inputBackgroundColor = node.level === 0 ? colorScheme.level0 :
                    node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                        node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                            '#ffffff';
                const textColor = getContrastTextColor(inputBackgroundColor);

                nodeDiv.innerHTML = `
            ${indent}
            ${collapseIcon}
            ${addButton}
            <input type="text" class="node-input" value="${node.text}" 
                   style="background-color: ${inputBackgroundColor}; color: ${textColor};"
                   oninput="validateInputLength(this, ${node.id})"
                   onchange="updateNodeText(${node.id}, this.value, this)"
                   placeholder="Knotenbeschriftung eingeben" 
                   draggable="false" 
                   data-node-id="${node.id}">
        `;


                const inputElement = nodeDiv.querySelector('.node-input');
                const addBtn = nodeDiv.querySelector('.add-btn');
                const deleteBtn = nodeDiv.querySelector('.delete-btn');
                const collapseIconElement = nodeDiv.querySelector('.collapse-icon');



                let isDragging = false;

                inputElement.addEventListener('mousedown', e => {
                    e.stopPropagation();
                    isDragging = false;
                    const input = e.target;
                    const rect = input.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const ctx = document.createElement('canvas').getContext('2d');
                    ctx.font = window.getComputedStyle(input).fontSize + ' ' + window.getComputedStyle(input).fontFamily;
                    const text = input.value;
                    let bestPosition = 0;
                    for (let i = 0; i <= text.length; i++) {
                        if (ctx.measureText(text.substring(0, i)).width + 10 >= clickX) {
                            bestPosition = i;
                            break;
                        }
                        bestPosition = i;
                    }
                    setTimeout(() => !isDragging && input.setSelectionRange(bestPosition, bestPosition), 0);
                });

                inputElement.addEventListener('click', e => {
                    e.stopPropagation();
                    if (isDragging) return e.preventDefault();
                    const input = e.target;
                    setTimeout(() => {
                        const rect = input.getBoundingClientRect();
                        if ((e.clientX - rect.left) > (rect.width - 20) * 0.9) {
                            input.setSelectionRange(input.value.length, input.value.length);
                        }
                    }, 10);
                });

                inputElement.addEventListener('keydown', e => (e.key === 'Enter' || e.keyCode === 13) && e.preventDefault() && e.target.blur());

                editor.appendChild(nodeDiv);
            });
        };



        // Help functions for node structure
        const getMaxDepth = nodeId => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node) return 0;
            const children = mindmapData.filter(n => n.parent === nodeId);
            return children.length ? Math.max(...children.map(child => 1 + getMaxDepth(child.id))) : 0;
        };

        const isDescendant = (ancestorId, nodeId) => {
            const node = mindmapData.find(n => n.id === nodeId);
            if (!node || node.parent === null) return false;
            return node.parent === ancestorId || isDescendant(ancestorId, node.parent);
        };

        const updateChildrenLevels = (nodeId, newLevel) => {
            mindmapData.filter(n => n.parent === nodeId).forEach(child => {
                child.level = newLevel + 1;
                child.branchIndex = mindmapData.find(n => n.id === nodeId).branchIndex;
                child.isCollapsed = child.level === 1 ? false : undefined;
                updateChildrenLevels(child.id, child.level);
            });
        };

        const normalizeOrders = () => {
            const groups = {};
            mindmapData.forEach(node => {
                const key = node.parent === null ? 'root' : node.parent;
                groups[key] = groups[key] || [];
                groups[key].push(node);
            });
            Object.values(groups).forEach(group => {
                group.sort((a, b) => (a.order || 0) - (b.order || 0) || a.id - b.id)
                    .forEach((node, index) => node.order = index + 1000);
            });
        };

        // Mermaid and SVG generation
        const generateMermaidCode = () => {
            if (!mindmapData.length) return 'mindmap|root(Hauptknoten)';
            const rootNode = mindmapData.find(node => node.level === 0);
            if (!rootNode) return 'mindmap|root(Hauptknoten)';
            const addNodeToMermaid = (node, level = 0) => {
                const indent = '~'.repeat(level);
                const text = node.text.replace(/[]/g, '');
                let nodeCode = node.level === 0 ? `${indent}root(${text})` : `${indent}${text}`;
                const children = mindmapData.filter(child => child.parent === node.id).sort((a, b) => (a.order || 0) - (b.order || 0));
                return nodeCode + children.map(child => '|' + addNodeToMermaid(child, level + 1)).join('');
            };
            return 'mindmap|' + addNodeToMermaid(rootNode);
        };

        const buildTreeFromData = () => {
            const nodesMap = new Map(mindmapData.map(node => [node.id, { ...node, children: [] }]));
            let root = null;
            nodesMap.forEach(node => {
                if (node.level === 0) root = node;
                if (node.parent !== null) {
                    const parent = nodesMap.get(node.parent);
                    if (parent) parent.children.push(node);
                }
            });
            const sortChildren = node => {
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach(sortChildren);
            };
            if (root) sortChildren(root);
            return root;
        };

        // Assign colors for branches
        const assignBranchColors = node => {
            const colorElement = document.getElementById('color-##id##');
            let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';
            const colorScheme = BRANCH_COLORS_SCHEMES[selectedScheme] || BRANCH_COLORS_SCHEMES['Standard'];

            node.color = node.level === 0 ? colorScheme.level0 :
                node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                    node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                        '#ffffff';
            node.textColor = getContrastTextColor(node.color);
            node.borderColor = node.level === 0 ? colorScheme.level0 : node.color;
            node.children.forEach((child, index) => {
                assignBranchColors(child);
            });
        };



        const countNodes = node => 1 + node.children.reduce((sum, child) => sum + countNodes(child), 0);

        // Calculate sub-tree size
        const calculateSubtreeSize = (node) => {
            const fontSize = Math.max(12, 18 - node.level);
            const maxWidth = 200;
            const words = node.text.split(' ').flatMap(word => {
                if (measureTextWidth(word, fontSize) > maxWidth) {
                    return splitLongWord(word, maxWidth, fontSize);
                }
                return word;
            });
            let line = '';
            const lines = [];

            words.forEach(word => {
                const testLine = line + word + ' ';
                if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                    lines.push(line.trim());
                    line = word + ' ';
                } else {
                    line = testLine;
                }
            });
            if (line.length > 0) lines.push(line.trim());

            const lineHeight = fontSize * 1.2;
            node.height = lines.length * lineHeight + 20;
            node.width = Math.max(100, maxWidth + 20);

            if (!node.children.length) {
                node.subtreeWidth = node.width;
                node.subtreeHeight = node.height;
                return;
            }
            node.children.forEach(calculateSubtreeSize);
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            node.subtreeHeight = node.children.reduce((sum, child) => sum + child.subtreeHeight, 0) + Math.max(0, node.children.length - 1) * spacing;
            node.subtreeWidth = node.width + 100 + Math.max(...node.children.map(c => c.subtreeWidth));
        };

        // Position nodes
        const positionNode = (node, x, y, direction) => {
            if (typeof node.x === 'undefined') {
                node.x = direction === 'left' ? x - node.width : x;
            }
            node.y = y + (node.subtreeHeight - node.height) / 2;
            const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));
            let currentY = y;
            node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
            node.children.forEach(child => {
                const childDirection = child.direction || direction;
                const offset = 100;
                const childX = childDirection === 'right' ? node.x + node.width + offset : node.x - offset;
                positionNode(child, childX, currentY, childDirection);
                currentY += child.subtreeHeight + spacing;
            });
        };


        // Calculate layout
        const calculateLayout = (node, level = 0) => {
            if (level === 0) {
                calculateSubtreeSize(node);
                let rightChildren = [];
                let leftChildren = [];
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach((child, index) => {
                    child.direction = index % 2 === 0 ? 'right' : 'left';
                    if (child.direction === 'right') rightChildren.push(child);
                    else leftChildren.push(child);
                });

                const spacing = Math.max(10, ...node.children.map(child => child.height * 0.5));

                let rightTotalHeight = rightChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, rightChildren.length - 1) * spacing;
                let leftTotalHeight = leftChildren.reduce((sum, c) => sum + c.subtreeHeight, 0) + Math.max(0, leftChildren.length - 1) * spacing;
                let maxTotalHeight = Math.max(leftTotalHeight, rightTotalHeight, node.height);

                const maxRightWidth = rightChildren.reduce((max, c) => Math.max(max, c.subtreeWidth), 0);
                const maxLeftWidth = leftChildren.reduce((max, c) => Math.max(max, c.subtreeWidth), 0);
                const maxBranchWidth = Math.max(maxRightWidth, maxLeftWidth);
                const totalWidth = node.width + 2 * maxBranchWidth + 200;

                node.x = maxBranchWidth + 100;
                node.y = maxTotalHeight / 2 - node.height / 2;

                let rightY = node.y + node.height / 2 - rightTotalHeight / 2;
                rightChildren.forEach(child => {
                    positionNode(child, node.x + node.width + 100, rightY, 'right');
                    rightY += child.subtreeHeight + spacing;
                });

                let leftY = node.y + node.height / 2 - leftTotalHeight / 2;
                leftChildren.forEach(child => {
                    const rightEdgeX = node.x - 100;
                    positionNode(child, rightEdgeX, leftY, 'left');
                    leftY += child.subtreeHeight + spacing;
                });
            }
        };

        // Calculate connection points
        const getConnectionPoint = (fromNode, toNode) => {
            const fromCenterX = fromNode.x + fromNode.width / 2;
            const fromCenterY = fromNode.y + fromNode.height / 2;
            const toCenterX = toNode.x + toNode.width / 2;
            const toCenterY = toNode.y + toNode.height / 2;
            const dx = toCenterX - fromCenterX;
            const dy = toCenterY - fromCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const normalizedDx = dx / distance;
            const normalizedDy = dy / distance;
            return {
                fromX: fromCenterX + normalizedDx * (fromNode.width / 2),
                fromY: fromCenterY + normalizedDy * (fromNode.height / 2),
                toX: toCenterX - normalizedDx * (toNode.width / 2),
                toY: toCenterY - normalizedDy * (toNode.height / 2)
            };
        };

        // UPDATED: Build tree from data considering collapsed nodes
        const buildTreeFromDataForSVG = () => {
            const nodesMap = new Map(mindmapData.map(node => [node.id, { ...node, children: [] }]));
            let root = null;

            nodesMap.forEach(node => {
                if (node.level === 0) root = node;
                if (node.parent !== null) {
                    const parent = nodesMap.get(node.parent);
                    if (parent) {
                        // Only add child if parent is not collapsed (for level 1 nodes)
                        if (parent.level !== 1 || !parent.isCollapsed) {
                            parent.children.push(node);
                        }
                    }
                }
            });

            const sortChildren = node => {
                node.children.sort((a, b) => (a.order || 0) - (b.order || 0));
                node.children.forEach(sortChildren);
            };
            if (root) sortChildren(root);
            return root;
        };

        // Generate SVG
        const generateSVG = root => {
            if (!root) return '';
            const padding = 100;
            assignBranchColors(root);
            calculateLayout(root);
            const { minX, minY, maxX, maxY } = getBounds(root);
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;
            let svg = `<svg width="${width}" height="${height}" viewBox="${minX - padding} ${minY - padding} ${width} ${height}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">`;
            const drawConnections = node => {
                node.children.forEach(child => {
                    const { fromX, fromY, toX, toY } = getConnectionPoint(node, child);
                    svg += `<line x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}" stroke="${BRANCH_COLORS[child.branchIndex % BRANCH_COLORS.length] || '#667eea'}" stroke-width="2" stroke-linecap="round"/>`;
                    drawConnections(child);
                });
            };
            const drawNodes = node => {
                const colorElement = document.getElementById('color-##id##');
                let selectedScheme = colorElement && colorElement.innerText.trim() ? colorElement.innerText.trim() : 'Standard';
                const colorScheme = BRANCH_COLORS_SCHEMES[selectedScheme] || BRANCH_COLORS_SCHEMES['Standard'];
                const { fillColor, fillOpacity, strokeColor, strokeWidth, strokeDasharray } = node.level === 0
                    ? { fillColor: colorScheme.level0, strokeColor: colorScheme.level0, strokeWidth: 2, strokeDasharray: 'none' }
                    : node.level === 1
                        ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: 'none' }
                        : node.level === 2
                            ? { fillColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], fillOpacity: '0.6', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' }
                            : { fillColor: '#ffffff', strokeColor: BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length], strokeWidth: 2, strokeDasharray: '5,3' };
                const textColor = getContrastTextColor(fillColor);

                // Add collapse indicator for level 1 nodes that have children
                const originalNode = mindmapData.find(n => n.id === node.id);
                const hasChildren = mindmapData.some(n => n.parent === node.id);
                let collapseIndicator = '';
                if (node.level === 1 && hasChildren) {
                    const isCollapsed = originalNode && originalNode.isCollapsed;
                    const indicatorX = node.x + node.width - 15;
                    const indicatorY = node.y + 10;
                    collapseIndicator = `<text x="${indicatorX}" y="${indicatorY}" font-size="12" font-family="FontAwesome" fill="${textColor}" text-anchor="middle">${isCollapsed ? '+' : ''}</text>`;
                }

                svg += `<rect data-node-id="${node.id}" class="node-rect" x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="8" fill="${fillColor}" fill-opacity="${fillOpacity || '1'}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${strokeDasharray}" style="cursor: ${node.level === 1 && hasChildren ? 'pointer' : 'default'}"/>`;

                const words = node.text.split(' ').flatMap(word => {
                    const fontSize = Math.max(12, 18 - node.level);
                    if (measureTextWidth(word, fontSize) > 200) {
                        return splitLongWord(word, 200, fontSize);
                    }
                    return word;
                });
                let line = '';
                const lines = [];
                const maxWidth = 200;
                const fontSize = Math.max(12, 18 - node.level);
                words.forEach(word => {
                    const testLine = line + word + ' ';
                    if (measureTextWidth(testLine, fontSize) > maxWidth && line.length > 0) {
                        lines.push(line.trim());
                        line = word + ' ';
                    } else {
                        line = testLine;
                    }
                });
                if (line.length > 0) lines.push(line.trim());
                const lineHeight = fontSize * 1.2;
                const totalTextHeight = lines.length * lineHeight;
                const startY = node.y + (node.height - totalTextHeight) / 2 + lineHeight * 0.7;
                lines.forEach((textLine, index) => {
                    svg += `<text data-node-id="${node.id}" class="node-text" x="${node.x + node.width / 2}" y="${startY + index * lineHeight}" font-size="${fontSize}" font-family="Inter, system-ui, sans-serif" fill="${textColor}" text-anchor="middle" font-weight="${node.level === 0 ? '600' : '400'}" style="cursor: ${node.level === 1 && hasChildren ? 'pointer' : 'default'}">${textLine}</text>`;
                });

                svg += collapseIndicator;
                node.children.forEach(drawNodes);
            };
            drawConnections(root);
            drawNodes(root);
            svg += '</svg>';
            return svg;
        };

        // Grenzen berechnen
        const getBounds = root => {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const updateBounds = node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
                node.children.forEach(updateBounds);
            };
            updateBounds(root);
            return { minX, minY, maxX, maxY };
        };

        // UPDATED: Render mind maps with SVG collapse functionality
        const renderMindmap = () => {
            if (!mermaidInput) return;
            mermaidInput.value = generateMermaidCode();
            if (!previewContainer) return;
            previewContainer.innerHTML = '<div class="loading">Rendere Mindmap...</div>';
            try {
                const root = buildTreeFromDataForSVG(); // Use the new function
                const svg = generateSVG(root);
                previewContainer.innerHTML = `<div id="mermaid-container-${Date.now()}" class="mermaid-container">${svg}</div>`;
                const existingOverlay = document.querySelector('.node-action-overlay, .input-overlay');
                if (existingOverlay) existingOverlay.remove();
                const svgContainer = previewContainer.querySelector('svg');
                if (svgContainer) {
                    svgContainer.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const existingOverlay = document.querySelector('.node-action-overlay, .input-overlay');
                        if (existingOverlay) existingOverlay.remove();
                        const target = e.target.closest('[data-node-id]');
                        if (target) {
                            const nodeId = parseInt(target.getAttribute('data-node-id'));
                            const node = mindmapData.find(n => n.id === nodeId);
                            if (!node) {
                                showErrorModal('Knoten nicht gefunden.');
                                return;
                            }

                            // SPECIAL HANDLING: Level 1 nodes with children - toggle collapse on click
                            if (node.level === 1 && mindmapData.some(n => n.parent === nodeId)) {
                                toggleCollapse(nodeId);
                                return; // Exit early, don't show the action overlay
                            }


                            document.body.appendChild(overlay);
                            overlay.querySelector('.edit-btn').addEventListener('click', (e) => {
                                e.stopPropagation();
                                overlay.remove();
                                const inputOverlay = document.createElement('div');
                                inputOverlay.className = 'input-overlay';
                                const overlayWidth = (rect.width / zoomFactor) * 1;
                                inputOverlay.style.left = `${rect.left + window.scrollX - (overlayWidth - rect.width / zoomFactor) / 2}px`;
                                inputOverlay.style.top = `${rect.top + window.scrollY}px`;
                                inputOverlay.style.width = `${overlayWidth}px`;
                                inputOverlay.style.height = `${rect.height / zoomFactor}px`;
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.value = node.text;
                                const colorElement = document.getElementById('color-##id##');
                                let selectedScheme = colorElement ? colorElement.innerText.trim() : 'Standard';
                                const inputBackgroundColor = node.level === 0 ? BRANCH_COLORS_SCHEMES[selectedScheme].level0 :
                                    node.level === 1 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                                        node.level === 2 ? BRANCH_COLORS[node.branchIndex % BRANCH_COLORS.length] :
                                            '#ffffff';
                                input.style.backgroundColor = inputBackgroundColor;
                                input.style.color = getContrastTextColor(inputBackgroundColor);
                                inputOverlay.appendChild(input);
                                document.body.appendChild(inputOverlay);
                                input.focus();
                                input.select();

                                let isSaving = false;



                            });

                        }
                    });
                }
                // Ensure welcome message visibility is correct after rendering
                if (welcomeMessage && !hasInteractedWithRoot && !mindmapData.some(node => node.parent !== null)) {
                    welcomeMessage.style.display = 'block';
                } else if (welcomeMessage) {
                    welcomeMessage.style.display = 'none';
                }
            } catch (error) {
                const mermaidCode = mermaidInput.value.split('|').map(line => {
                    const match = line.match(/^(~*)[^~]*/);
                    return match ? ' '.repeat(match[1]?.length || 0) + match[0].replace(/^~*/, '') : line;
                }).join('\n');
                previewContainer.innerHTML = `
                    <div style="background: #f1f3f4; padding: 20px; border-radius: 12px; border-left: 4px solid #dc2626;">
                        <h4 style="margin: 0 0 10px 0; color: #dc2626;">‚ö†Ô∏è Vorschau nicht verf√ºgbar</h4>
                        <p style="color: #6b7280; margin: 0 0 15px 0; font-size: 14px;">Rendering-Fehler: ${error.message}</p>
                        <h5 style="margin: 15px 0 10px 0; color: #1f2937;">üìã Generierter Code:</h5>
                        <pre style="background: white; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4; overflow-x: auto; margin: 0; border: 1px solid #e5e7eb;">${mermaidCode}</pre>
                    </div>
                `;
                if (welcomeMessage) welcomeMessage.style.display = 'none'; // Hide message on error
            }
        };
    </script>
</div>